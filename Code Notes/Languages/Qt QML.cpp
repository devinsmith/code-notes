/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML ENGINE / QT QUICK
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
===========================================================================================================
QML MEMORY ALLOCATION
===========================================================================================================
• Using QML allocates both in C++ heap and javascript garbage collected heap
• WorkerScripts share their own seperate Javascript heap, only allocated if WorkerScript is used
• Adding custom properties makes it an implicit type of the component (allocates memory for new type) 
• Not adding custom properties makes it an explicit type of the component (shares memory for type)

C++ HEAP ALLOCATIONS:
• Overhead of the QML engine (implementation data structures, context information)
• Per-component compiled data and type information, depending which modules/components used
• Per-object C++ data/property values, plus metaobject hierarchy, depending which modules/components used
• Any data which is allocated specifically by QML libraries

JAVASCRIPT HEAP ALLOCATIONS:
• Javascript engine itself including built in types
• Javascript integration: constructor functions for loaded types, function templates
• Variables allocated during expression evaluation
• Per-type layout information and other internal type-data generated by the JavaScript engine at runtime
• Per-object JavaScript data: var properties, functions/signal handlers, non-optimized binding expressions

===========================================================================================================
QML SCENE GRAPH
===========================================================================================================
• Low-level, high-performance rendering stack that renders QML visual items using OpenGL by default
• Allows the scene to be retained between frames and complete set of primitives is known before rendering
• Allows optimizations such as batch rendering to minimize state changes and discarding obscured primitives
• Managed and rendered by the QQuickWindow class 
• Three render loop types: Basic/Windows uses main thread, Threaded uses dedicated thread
• Render loop type auto chosen for hardware, usually Threaded, QSG_RENDER_LOOP forces type
  
SCENE GRAPH NODES
• Added by subclassing QQuickItem::updatePaintNode and setting the QQuickItem::ItemHasContents flag
• Only use classes with the "QSG" prefix inside the QQuickItem::updatePaintNode
• To preprocess, set QSGNode::UsePreprocess and override QSGNode::preprocess; called before rendering
• Each node uses a material (simple OpenGL shader program)

SCENE GRAPH NODE TYPES:
QSGClipNode           Implements the clipping functionality in the scene graph
QSGGeometryNode       Used for all rendered content, describes the shape/mesh of the primitive
QSGNode               The base class for all nodes in the scene graph
QSGOpacityNode        Used to change opacity of nodes
QSGTransformNode      Implements transformations in the scene graph
QSGSimpleRectNode     QSGGeometryNode which defines a rectangular geometry with a solid color material
QSGSimpleTextureNode  QSGGeometryNode which defines a rectangular geometry with a texture material

SCENE GRAPH THREADED RENDER LOOP:
1) QQuickItem::update called when QML scene changed
2) Render thread prepares to draw a new frame
3) Meanwhile GUI thread calls QQuickItem::updatePolish to do final item touch-up
4) GUI thread is blocked
5) QQuickWindow::beforeSynchronizing signal is emitted
6) Synchronization of the QML state into the scene graph by calling QQuickItem::updatePaintNode
7) GUI thread block is released
8) The scene graph is rendered:
     1) QQuickWindow::beforeRendering signal is emitted
     2) QSGNode::preprocess called for those that use it
     3) Renderer processes the nodes and calls OpenGL functions
     4) QQuickWindow::afterRendering signal is emitted
     5) Rendered frame is swapped and QQuickWindow::frameSwapped is emitted
9) Meanwhile GUI is free to advance animations, process events, etc
**************************************************************************************************************/
    
// QQuickWindow
// Inherits QWindow, window for QML applications

// QQuickView 
// Wrapper for QQuickWindow to automatically load and display a QML scene from an url

// QQuickWidget
// Wrapper for QQuickWindow to automatically load and display a QML scene from an url
// Less stacking order restrictions, though slower compared to QQuickWindow/QQuickView
// Disables the threaded render loop on all platforms
// Avoid calling winId; triggers creation of a native window, resulting in reduced performance

// QQuickItem
// Inherits QObject, instantiated by Item QML component
// Properties have accessors item.property() and item.setProperty()
item.activeFocus // Read only, whether item has active focus
item.activeFocusOnTab // Whether included in active focus on tab, default false
item.antialiasing // Whether antialiasing enable, default false
item.baselineOffset // Position offset, default 0, used for text
item.childrenRect // Read only, QRectF collective position and size of the item's children
item.clip // Whether clipping enabled, default false, hides part of item/children, performance hit
item.enabled // Recursive, whether the item receives mouse and keyboard events
item.focus // Whether item has input focus
item.height // Actual height of item
item.width // Actual width of item
item.implicitHeight // Default height of the Item if no height is specified
item.implicitWidth // Default width of the Item if no width is specified
item.opacity // Alpha of item, values outside [0,1] clamped
item.objectName // Inherited from QObject
item.parent // QQuickItem*, visual parent of the item
item.rotation // rotation of the item in degrees clockwise around its transformOrigin, default 0
item.scale // size of item, negative mirror's item, default 1
item.smooth // Image interpolation, true is linear, false is nearest neighbour, default true
item.state // QString state name, default empty
item.transformOrigin // TransformOrigin type which scale/rotate use
item.visible // Recursive, whether item is rendered
item.x / item.y / item.z // Position and stacking depth of item, negative z draws under parent
item.childAt(x, y) // Returns first visible QQuickItem* child found at point within item coord system
item.childItems() // Returns QList<QQuickItem*>
item.componentComplete() // Called when the item has been instantiated
item.contains(point) // If item contains QPointF (in local coordinates)
item.cursor() // Returns QCursor enum for cursor type when mouse over item, default Qt::ArrowCursor
item.flag() // Returns Flags enum value
item.forceActiveFocus(reason) // Focuses item and any parent FocusScopes, reason optional
item.grabMouse() // Item will receive all mouse events until ungrabMouse is called
item.isComponentComplete() // If construction of the QML component is complete
item.isFocusScope() // If item is a FocusScope
item.keepMouseGrab() // Whether mouse input should exclusively remain with this item
item.mapFromGlobal(point) // Converts global coords into item local coords, returns QPointF
item.mapFromItem(item2, point) // Converts item2 local coords into item local coords, returns QPointF
item.mapFromScene(point) // Converts scene coords into item local coords, returns QPointF
item.mapRectFromItem(item2, rect) // Converts item2 local coords into item local coords, returns QRectF
item.mapRectFromScene(rect) // Converts scene coords into item local coords, returns QRectF
item.mapRectToItem(item2, rect) // Converts item local coords into item2 local coords, returns QRectF
item.mapRectToScene(rect) // Converts item local coords into scene coords, returns QRectF
item.mapToGlobal(point) // Converts item local coords into global coords, returns QPointF
item.mapToItem(item2, point) // Converts item local coords into item2 local coords, returns QPointF
item.mapToScene(point) // Converts item local coords into scene coords, returns QPointF
item.nextItemInFocusChain(forward) // Returns next QQuickItem* in the focus chain, whether to move forward
item.scopedFocusItem() // If item is a FocusScope, returns the item in its focus chain with current focus
item.setCursor(cursor) // Sets the cursor shape for this item
item.setFlags(flags) // Enables the specified flags for this item
item.stackAfter(sibling) // Moves sibling QQuickItem* to the index after item in the list of children
item.stackAfter(sibling) // Moves sibling QQuickItem* to the index before item in the list of children
item.ungrabMouse() // Releases the mouse grab following a call to grabMouse
item.unsetCursor() // Clears the cursor shape for this item
item.update() // Schedules a call to updatePaintNode
item.updatePaintNode(oldNode, nodeData) // Called on render thread to sync the item with scene graph
item.updatePolish() // Called to do item layout before rendering the next frame
item.widthValid() // whether the width property has been set explicitly
item.heightValid() //whether the height property has been set explicitly
item.window() // Return QQuickWindow* in which this item is rendered
 
// QQuickPaintedItem
// Inherits QQuickItem, allows rendering content using QPainter

// QQmlEngine
qmlRegisterSingletonType(QUrl("qrc:///MyGlobal.qml"), "MyGlobals", 1, 0, "MyGlobal")
qmlRegisterType<MyClass>("MyEnums", 1, 0, "MyEnum") // MyEnum must be in Q_OBJECT class
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QT MODELING LANGUAGE (QML)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import QtQuick 2.6
import QtQuick.Controls 1.4
import MyEnums 1.0
import MyGlobals 1.0
import "MyJavascript.js" as MyJS
  
// ITEM
// Base for most QML components, instantiates QQuickItem
Item {
    id: item                               // unique id of item, can be used to access it
    property int myProperty: 0             // custom property
    property int myProperty: myProperty2   // if myProperty2 changes, re-evaluates myProperty
    property int myProperty: myFunction    // if properties used in function changes, re-evaluates myProperty
    property int myProperty: { return 0; } // if properties used in function changes, re-evaluates myProperty
    property int myProperty: MyJS.fn       // Use function from imported javascript file
    property int myProperty: MyGlobal.fn   // Use function from global singleton
    property int myProperty: MyEnum.ONE    // Use int type for enums
    property int myProperty: myObj.value   // Context Q_OBJECT with Q_PROPERTY 'value' with NOTIFY
    readonly property int myProperty: 0    // read-only property
    property alias myAlias: myProperty     // reference for property
    signal mySignal(int value)             // call with item.mySignal(0)
      
    /* Called when the item has been instantiated */
    Component.onCompleted: {}

    /* Called when the item is destroyed */
    Component.onDestruction: {}

    /* Called when property has changed, for context Q_OBJECTs emit signal needed */
    onMyPropertyChanged: {}
  
    /* Called when signal emitted */
    onMySignal: { console.log(value); }
  
    /* Called when signal emitted, requires calling signal.connect */
    function mySlot(value) {}

    /* Javascript custom function */
    function myFunction(x, y) {
        return x + y;
    }
  
    /* Item states, if multiple 'when' true, first is chosen */
    states: [
        State {
            name: "state1" 
            PropertyChanges { target: item; myProperty: 1 } 
            when: myBoolProperty
        },
        State { 
            name: "state2" 
            PropertyChanges { target: item; myProperty: 2 }
            when: myFunction
        }
    ]
}
item.mySignal.connect(mySlot) // Connect signal and slot
item.activeFocus // Read only, whether item has active focus
item.activeFocusOnTab // Whether included in active focus on tab, default false
item.antialiasing // Whether antialiasing enable, default false
item.baselineOffset // Position offset, default 0, used for text
item.childrenRect // Read only, QML rect collective position and size of the item's children
item.clip // Whether clipping enabled, default false, hides part of item/children, performance hit
item.enabled // Recursive, whether the item receives mouse and keyboard events
item.focus // Whether item has input focus
item.height // Actual height of item
item.width // Actual width of item
item.implicitHeight // Default height of the Item if no height is specified
item.implicitWidth // Default width of the Item if no width is specified
item.opacity // Alpha of item, values outside [0,1] clamped
item.objectName // Inherited from QObject
item.parent // returns Item, visual parent of the item
item.rotation // rotation of the item in degrees clockwise around its transformOrigin, default 0
item.scale // size of item, negative mirror's item, default 1
item.smooth // Image interpolation, true is linear, false is nearest neighbour, default true
item.transformOrigin // TransformOrigin type which scale/rotate use
item.visible // Recursive, whether item is rendered
item.x / item.y / item.z // Position and stacking depth of item, negative z draws under parent
item.anchors // Sub options: top, bottom, left, right, horizontalCenter, verticalCenter, baseLine
item.anchors.fill // Takes QML Item parent or sibling, set to undefined to detach
item.anchors.centerIn // Takes QML Item parent or sibling, set to undefined to detach
item.anchors.margins // Set value for all margins
item.anchors.topMargin // Set value for top margin
item.anchors.bottomMargin // Set value for bottom margin
item.anchors.leftMargin // Set value for left margin
item.anchors.rightMargin // Set value for right margin
item.anchors.horizontalCenterOffset // Value offset from horizontal center
item.anchors.verticalCenterOffset // Value offset from vertical center
item.anchors.baselineOffset // Value offset from position
item.anchors.alignWhenCentered // forces centered anchors to align to a whole pixel, default true
item.data // list<Object> of both visual children and resources
item.layer.effect // Component, typically a ShaderEffect component
item.layer.enabled // Whether the item is layered or not, disabled by default
item.layer.format // Enum, internal OpenGL format of the texture
item.layer.mipmap // Whether mipmaps are generated for the texture
item.layer.samplerName // Name of the effect's source texture property
item.layer.samples // Enum, allows requesting multisampled rendering in the layer
item.layer.smooth // Whether the layer is smoothly transformed
item.layer.sourceRect // The rectangular area of the item that should be rendered into the texture
item.layer.textureMirroring // Enum, how the generated OpenGL texture should be mirrored
item.layer.textureSize // Pixel size of the layers texture, if empty (default) uses item's size
item.layer.wrapMode // Enum, OpenGL wrap modes associated with the texture
item.resources // list<Object>, contains non-visual children
item.state // QString state name, default empty
item.states // list<State>, list of possible states for this item
item.transform // list<Transform>, list of transformations to apply
item.transitions // list<Transition>, transitions to be applied to the item whenever it changes its state
item.visibleChildren // list<Item>, contains visual children
item.childAt(x, y) // Returns first visible QML Item child found at point within item coord system
item.contains(point) // If item contains QML point (in local coordinates)
item.forceActiveFocus(reason) // Focuses item and any parent FocusScopes, reason optional
item.grabToImage(callback, targetSize) // Grabs the item into an in-memory image
item.mapFromGlobal(x, y) // Converts global coords into item local coords, retuns QML point
item.mapFromItem(item2, x, y, w, h) // Converts item2 local coords into item local coords, retuns QML rect
item.mapFromItem(item2, x, y) // Converts item2 local coords into item local coords, retuns QML point
item.mapToGlobal(x, y) // Converts item local coords into global coords, returns QML point
item.mapToItem(item2, x, y, w, h) // Converts item local coords into item2 local coords, returns QML rect
item.mapToItem(item2, x, y) // Converts item local coords into item2 local coords, returns QML point
item.nextItemInFocusChain(forward) // Returns item next in the focus chain, forward optional

// MyGlobal.qml
// Requires registering to enable as global
pragma Singleton
import QtQuick 2.4
QtObject {
    property value: 0
    function fn() {
        return 0;
    }
}

// MyJavascript.js
// Make a library to enable sharing across all QML files
var value = 0;
function fn() {
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML BASIC TYPES
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
property bool myBool: true
property double myDouble: 0.0
property int myInt: 0
property real myReal: 0.0

// VAR
// Use for holding Javascript types, QVariantMap and variant
// Object attributes do not send signal or update bindings when changed
property var myFn: (function() { return 0; }) // Javascript function
property var myArray: [1, 2, 3, "a", "b"] // Javascript array
property var myObj: { "a":0, "b":1 } // Javascript object
property var myObj: ({ a:0, b:1 }) // Javascript object, requires () without "
property var myObj: new Object({ "a":0, "b":1 }) // Javascript object
property int myAttr: myObj.a // Will not update when 'a' updates

// LIST
// list of QML objects, not a Javascript array
// Auto converts to/from QmlListProperty
property list myList: [] 
myList.length // item count in list
myList[index] // access item
  
// POINT
// Auto converts to/from QPoint and QPoint
// Attributes do not have signals, use onMyPointChanged instead
property point myPoint: Qt.point(0, 20)
property point myPoint: "0,20"
myPoint.x / myPoint.y
  
// RECT
// Auto converts to/from QRect and QRectF
// Attributes do not have signals, use onMyRectChanged instead
property rect myRect: "50,50,100x100"
property rect myRect: Qt.rect(50, 50, 100, 100)
myRect.x / myRect.y
myRect.width
myRect.height
myRect.top // read-only
myRect.bottom // read-only
myRect.left // read-only
myRect.right // read-only

// SIZE
// Auto converts to/from QSize and QSizeF
// Attributes do not have signals, use onMySizeChanged instead
property size mySize: "150x50"
property size mySize: Qt.size(150, 50)
mySize.width
mySize.height

// URL
// Auto converts to/from QUrl
property url myUrl: "folder/image.png" // Relative path, will be converted to absolute
property url myUrl: "file:///folder/image.png" // Absolute path
property url myUrl: "qrc:///folder/image.png" // Resource path
myUrl == Qt.resolvedUrl("folder/image.png") // Comparison
myUrl.toString() // Returns the absolute path
Qt.resolvedUrl(myUrl) // Returns url resolved relative to the URL of the caller

// STRING
// Auto converts to/from QString
// Attributes do not have signals, use onMyStrChanged instead
property string myStr: "str"
myStr.length
Qt.qsTrId(id) // returns translated string at id, else id if no translation
Qt.qsTrIdNoOp(id) // Marks id for dynamic translation, returns id

//===========================================================================================================
// QML DATE
//===========================================================================================================

// DATE
// Auto converts to/from QDate and QDateTime
property date myDate: "2020-12-31"
  
// Takes JavaScript Date or QML date, returns date as string
// Format defaults Qt.SystemLocaleShortDate, can be enum or string
Qt.formatDate(date, format)
Qt.formatDateTime(date, format)
Qt.formatTime(date, format)
  
// DATE FORMAT ENUM
Qt.TextDate                // ddd MMM d yyyy
Qt.ISODate                 // yyyy-MM-dd or yyyy-MM-ddTHH:mm:ss or with a time-zone suffix 
Qt.ISODateWithMs           // Qt.ISODate with ms
Qt.SystemLocaleShortDate   // The short format used by the operating system
Qt.SystemLocaleLongDate    // The long format used by the operating system
Qt.DefaultLocaleShortDate  // The short format specified by the application's locale
Qt.DefaultLocaleLongDate   // The long format specified by the application's locale
  
// DATE FORMAT STRING
// Can use space . and : to seperate (eg. "ddd MMMM d yy" )
d     // the day as number without a leading zero (1 to 31)
dd    // the day as number with a leading zero (01 to 31)
ddd   // the abbreviated localized day name (e.g. 'Mon' to 'Sun'). Uses QDate::shortDayName()
dddd  // the long localized day name (e.g. 'Monday' to 'Qt::Sunday'). Uses QDate::longDayName()
M     // the month as number without a leading zero (1-12)
MM    // the month as number with a leading zero (01-12)
MMM   // the abbreviated localized month name (e.g. 'Jan' to 'Dec'). Uses QDate::shortMonthName()
MMMM  // the long localized month name (e.g. 'January' to 'December'). Uses QDate::longMonthName()
yy    // the year as two digit number (00-99)
yyyy  // the year as four digit number
h     // the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
hh    // the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
m     // the minute without a leading zero (0 to 59)
mm    // the minute with a leading zero (00 to 59)
s     // the second without a leading zero (0 to 59)
ss    // the second with a leading zero (00 to 59)
z     // the milliseconds without leading zeroes (0 to 999)
zzz   // the milliseconds with leading zeroes (000 to 999)
AP    // use AM/PM display. AP will be replaced by either "AM" or "PM"
ap    // use am/pm display. ap will be replaced by either "am" or "pm"
t     // include a time-zone indicator

//===========================================================================================================
// QML COLOR
//===========================================================================================================

// COLOR
// ARGB color value, auto converts to/from QColor
// Attributes do not have signals, use onMyColorChanged instead
property color myColor: "red"
property color myColor: "#RRGGBB"
property color myColor: "#AARRGGBB"
property color myColor: Qt.rgba(r, g, b, a) // All real in range [0.0,1.0]
Qt.hsva(hue, saturation, value, alpha) // All real in range [0.0,1.0]
Qt.hsla(hue, saturation, lightness, alpha) // All real in range [0.0,1.0]
Qt.darker(myColor, v) // Returns darker color by converting to HSV then value/v, v <= 0 unspecified
Qt.darker(myColor) // Returns color 50% darker than myColor
Qt.lighter(myColor, v) // Returns lighter color by converting to HSV then value*v, v <= 0 unspecified
Qt.lighter(myColor) // Returns color 50% lighter than myColor
Qt.tint(myColor, tintColor) // Returns color with tintColor overlaying myColor
Qt.colorEqual(myColor, myColor2) // Either argument can be Color or string type
myColor.r / myColor.g / myColor.b / myColor.a
myColor.hsvHue
myColor.hsvSaturation
myColor.hsvValue 
myColor.hslHue
myColor.hslSaturation
myColor.hslLightness

//===========================================================================================================
// QML MATH
//===========================================================================================================

// MATRIX4X4
// Attributes do not have signals, use onMyMatChanged instead
property matrix4x4 myMat: Qt.matrix4x4(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
myMat.m11...myMat.m44
myMat.times(myMat2) // multiplying myMat with myMat4
myMat.times(myVec) // transforming vector3d or vector4d with the 4x4 matrix
myMat.times(value) // multiply matrix by real scalar
myMat.plus(myMat2) // myMat + myMat2
myMat.minus(myMat2) // myMat - myMat2
myMat.row(index) // returns vector4d, zero-based index
myMat.column(index) // returns vector4d, zero-based index
myMat.determinant() // returns real
myMat.inverted() // returns myMat inverted
myMat.transposed() // returns myMat transposed
myMat.fuzzyEquals(myMat2, epsilon) // epsilon is real
myMat.toString()

// QUATERNION
// Attributes do not have signals, use onMyQuatChanged instead
property quaternion myQuat: "1.0,0,1,0" // scalar,x,y,z
property quaternion myQuat: Qt.quaternion(1.0,0,1,0) // scalar,x,y,z
myQuat.x / myQuat.y / myQuat.z
myQuat.scalar

// VECTOR2D
// Attributes do not have signals, use onMyVecChanged instead
property vector2d myVec: "0,1"
property vector2d myVec: Qt.vector2d(0,1)
myVec.x / myVec.y
myVec.dotProduct(myVec2) // returns real
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector3d() // returns vector3d, z component is set to 0
myVec.toVector4d() // returns vector4d, z/w components set to 0
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

// VECTOR3D
// Attributes do not have signals, use onMyVecChanged instead
property vector3d myVec: "0,1,0"
property vector3d myVec: Qt.vector3d(0,1,0)
myVec.x / myVec.y / myVec.z
myVec.crossProduct(myVec2) // returns vector x vector2
myVec.dotProduct(myVec2) // returns real
myVec.times(matrix) // transforming vector with the 4x4 matrix
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector2d() // returns vector2d, z component dropped
myVec.toVector4d() // returns vector4d, w component set to 0
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

// VECTOR4D
// Attributes do not have signals, use onMyVecChanged instead
property vector4d myVec: "0,1,0,1"
property vector4d myVec: Qt.vector3d(0,1,0,1)
myVec.x / myVec.y / myVec.z / myVec.w
myVec.dotProduct(myVec2) // returns real
myVec.times(matrix) // transforming vector with the 4x4 matrix
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector2d() // returns vector2d, z/w components dropped
myVec.toVector3d() // returns vector3d, w component dropped
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

//===========================================================================================================
// QML FONT
//===========================================================================================================

// FONT
// Auto converts to/from QFont
// If no matching font exists, Qt will use the closest matching installed font
// Attributes do not have signals, use onMyFontChanged instead
property font myFont: Qt.font({ family: "Helvetica", weight: Font.Black })
Qt.fontFamilies() // Returns list<string> of font families available
myFont.family // String font family name
myFont.bold // Whether bold
myFont.italic // Whether italic
myFont.underline // Whether has underline
myFont.pointSize // real, device independent
myFont.pixelSize // Overrides pointSize, int, device dependent
myFont.weight // Weight enum
myFont.overline // Whether has overline
myFont.strikeout // Whether line through it
myFont.capitalization // Capitalization Rendering enum
myFont.letterSpacing // real, spacing between characters
myFont.wordSpacing // real, spacing between words
myFont.kerning // Whether to auto adjust character spacing, default enabled
myFont.preferShaping // Whether to enable display/spacing rules, default enabled
myFont.hintingPreference // Hinting preference enum

// WEIGHTING
Font.Thin          0
Font.ExtraLight    12
Font.Light         25
Font.Normal        50
Font.Medium        57
Font.DemiBold      63
Font.Bold          75
Font.ExtraBold     81
Font.Black         87
  
// CAPITALIZATION
Font.MixedCase       // No change
Font.AllUppercase    // Render in all uppercase
Font.AllLowercase    // Render in all lowercase
Font.SmallCaps       // Render in all small-caps
Font.Capitalize      // Render with the first character of each word as uppercase
  
// HINTING
// Adjusts an outline (non-rastor) font so it lines up with a rasterized grid
// Important for displaying small text, only used with "NativeRendering"
Font.PreferDefaultHinting    // default hinting level
Font.PreferNoHinting         // render text without hinting
Font.PreferVerticalHinting   // no horizontal hinting, but align in the vertical direction
Font.PreferFullHinting       // hinting in both horizontal and vertical directions

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML LAYOUTS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// LAYOUT PROPERTIES
// Use these on any components inside the layout
Layout.alignment // Alignment type flags
Layout.bottomMargin // Overrides margin property if set
Layout.column // column position of an item in a GridLayout
Layout.columnSpan // column span of an item in a GridLayout
Layout.fillHeight // Uses preferredHeight if false
Layout.fillWidth // Uses preferredWidth if false
Layout.leftMargin // Overrides margin property if set
Layout.margins // Spacing between items
Layout.maximumHeight // Number.POSITIVE_INFINITY default
Layout.maximumWidth // Number.POSITIVE_INFINITY default
Layout.minimumHeight // 0 default
Layout.minimumWidth // 0 default
Layout.preferredHeight // if -1 (default), will be ignored, and item's implicitHeight used instead
Layout.preferredWidth // if -1 (default), will be ignored, and item's implicitWidth used instead
Layout.rightMargin // Overrides margin property if set
Layout.row // row position of an item in a GridLayout
Layout.rowSpan // row span of an item in a GridLayout
Layout.topMargin // Overrides margin property if set

// ALIGNMENT TYPES
Qt.AlignLeft
Qt.AlignHCenter
Qt.AlignRight
Qt.AlignTop
Qt.AlignVCenter
Qt.AlignBottom
Qt.AlignBaseline

// ROWLAYOUT
// Inherits Item, Aligns elements after each other in a single row
RowLayout {
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

// COLUMNLAYOUT
// Inherits Item, Aligns elements after each other in a single column
ColumnLayout {
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

// GRIDLAYOUT
// Inherits Item, Aligns elements in a grid with n columns
GridLayout {
    columns: 3
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML COMPONENTS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// QTOBJECT
// lightweight non-visual element
QtObject {
   objectName: "name"
}

// COMPONENT
// Instantiates QQmlComponent, Used for sourceComponent and contentItem properties
Component {
    Rectangle {
        signal mySignal(int value)
    }
}

// CONNECTIONS
// Access a signal outside of the object that emits it, required for Loader items
Connections {
    target: loader.item
    onMySignal: { console.log(value); }
}

// BINDING
// Will become active and assign value to myProperty when myBoolean becomes true
// When active, will disable any direct bindings myProperty may have until myBoolean is false
Binding {
    target: item // required if not a child of item with property
    property: "myProperty" // can be QML basic type attribute (eg. "myRectProperty.x")
    when: myBoolean
    value: 10 // Can be value, another property etc
    delayed: true // wait until event queue cleared before assigning
}

// RECTANGLE
// Inherits Item
Rectangle {
    color: "red"
    radius: 2
    border.color: "red"
    border.width: 1      
}

// REPEATER
// Inherits Item, Usually in Row/Column, instantiates n items
// creates all of its delegate items when the repeater is first created
Repeater {
    id: repeater
    model: 3
    Text { text: "Item " + indeX + "/" + repeater.count }
}
Repeater {
    model: ["one", "two", "three"]
    Text { text: "Data: " + modelData }
}
Repeater {
    model: listView
    Text { text: "Data: " + modelData.role_name }
}

// TIMER
Timer {
    interval: 500 // milliseconds
    running: true
    repeat: true
    triggeredOnStart: true // default false, triggered signal emitted once extra on timer start
    onTriggered: {}
}
timer.restart()
timer.start()
timer.stop()
  
// INTVALIDATOR
// Instantiates QIntValidator
IntValidator {
    bottom: -1 // default -infinity
    top: 1 // default infinity
} 
  
// DOUBLEVALIDATOR
// Instantiates QDoubleValidator
DoubleValidator {
    bottom: -1.0 // default -infinity
    top: 1.0 // default infinity
    decimals: 1 // n digits after decimal point, default 1000
    notation: DoubleValidator.ScientificNotation // default 
}
DoubleValidator.StandardNotation     // disables E in value
DoubleValidator.ScientificNotation   // allow E in value
  
// ACTION
// Inherits QtObject, Can be used in MenuItem, Button, ToolButton 
Action {
    checkable: true // defaults false
    checked: true
    iconSource: "qrc:///icon.png"
    text: "str"
    shortcut: StandardKey.Copy
    onTriggered: {}
    onToggled: {}
}

//===========================================================================================================
// QML CONTROLS
//===========================================================================================================

// CONTROL
// Inherits Item, base class for all controls
Control {
}

// ABSTRACTBUTTON
// Inherits Control, base class for all buttons
AbstractButton {
    text: "str"
    action: myAction
    checkable: true // defaults false
    checked: true
    icon.source: "qrc:///icon.png"
    onClicked: {}
}
button.pressed

// BUTTON
// Inherits AbstractButton
Button {
}

// CHECKBOX
// Inherits AbstractButton
CheckBox {
}

// MENUITEM
// Inherits AbstractButton
MenuItem {
}

// PROGRESSBAR
// Inherits Control
ProgressBar {
    maximumValue: 20
    minimumValue: 0
    style: ProgressBarStyle {
        background: Rectangle {
            radius: 2
            color: "grey"
            implicitWidth: 100
            implicitHeight: 20
        }
        progress: Rectangle {
            color: "blue"
        }
    }
}

//===========================================================================================================
// QML POPUPS
//===========================================================================================================

// POPUP
// Inherits QtObject, base class for all popups
Popup {
}

// DIALOG
// Inherits Popup
Dialog {
    visible: false // Turning on/off will show dialog window
    title: "Title"
    width: 300
    height: 80
    contentItem: Rectangle {
        anchors.fill: parent
    }
}

// MENU
// Inherits Popup, Call using id.popup() to show at mouse position
Menu {
    visible: false // context menu start off invisible
    MenuSeparator { visible: true }
    MenuItem { text: "str" }
}

//===========================================================================================================
// QML TEXT
//===========================================================================================================

// TEXT
// Inherits item
Text {
    wrapMode: Text.NoWrap // default
    horizontalAlignment: Text.AlignHCenter
    verticalAlignment: Text.AlignVCenter     
}

// TEXTINPUT
// Inherits Item, single line of editable plain text
TextInput {
    wrapMode: TextInput.NoWrap // default
    horizontalAlignment: TextInput.AlignHCenter
    verticalAlignment: TextInput.AlignVCenter
    displayText: "str" // Dependent on echo mode, holds input as editing    
    activeFocusOnPress: true // If gain active focus on a mouse press
    autoScroll: true
    cursorDelegate: Rectangle {} // Override cursor
    echoMode: TextInput.Normal
    inputMask: ">AAAAA-AAAAA-AAAAA;#"
    inputMethodHints: Qt.ImhDigitsOnly | Qt.ImhTime
    validator: myValidator
    maximumLength: 100 // truncates/prevents input, default 32767
    mouseSelectionMode: TextInput.SelectCharacters // requires selectByMouse property on
    overwriteMode: true // Whether text inserted will overrite (insert key behavior)
    passwordCharacter: "*" // Character used with echomode Password, only first char is used
    passwordMaskDelay: 10 // ms delay before masking the character for echomode Password
    persistentSelection: true // Whether keep selection when focus lost, default false
    readOnly: true
    selectByMouse: true // Allow mouse to select, default false
    selectedTextColor: "red" // text
    selectionColor: "red" // background
    onAccepted() {} // when Return/Enter key pressed and text passed validation
    onEditingFinished() {} // when Return/Enter key pressed or focus lost and text passed validation
    onTextEdited() {} // whenever the text is edited by user, not explicitly set
}
input.acceptableInput // if validator/input mask has been set, true if valid, if not set, always true
input.canUndo // If writable and there are previous operations that can be undone
input.canPaste // If writable and the content of the clipboard can be pasted into input
input.canRedo // If writable and there are undone operations that can be redone
input.cursorPosition // position of the cursor in input
input.cursorRectangle // rectangle where the cursor is rendered within inout
input.cursorVisible // True when input shows a cursor
input.length // Length of text, if has inputMask will include mask characters
input.preeditText // partial text input from an input method
input.selectedText // currently selected text
input.selectionEnd // index after last character where selection ends in 'text', read-only
input.selectionStart // index of first character where selection starts in 'text', read-only
input.clear() // clears text
input.copy() // Copies selected text to system clipboard, won't work for Password echomode
input.cut() // Cuts selected text to system clipboard, won't work for Password echomode
input.deselect() // Removes selection
input.ensureVisible(position) // Scrolls the contents to position
input.getText(start, end) // Returns section of text between start and end positions
input.insert(position, "str") // Inserts at position
input.isRightToLeft(start, end) // true if natural reading direction between start/end is right to left
input.moveCursorSelection(position, selectionMode) // Moves cursor and selects while moving
input.paste() // Replaces the currently selected text by the contents of the system clipboard
input.positionAt(x, y, cursorPosition) // Returns position from topleft of input based on cursorPosition
input.positionToRectangle(position) // Returns QML rect that cursor would occupy if placed at char position
input.redo() // Redos if possible
input.remove(start, end) // Removes section of text between start and end position
input.select(start, end) // Selects start to end char position, if out of range does no selection change
input.selectAll() // Causes all text to be selected
input.selectWord() // Selects word closest to the current cursor position
input.undo() // Undos if possible

// TEXTEDIT
// Inherits Item
TextEdit {
    wrapMode: TextEdit.NoWrap // default
    horizontalAlignment: TextEdit.AlignHCenter
    verticalAlignment: TextEdit.AlignVCenter  
}
  
// LABEL
// Inherits Text
Label {
}

// TEXTFIELD
// Inherits TextInput
TextField {
}

// TEXTAREA
// Inherits TextEdit
TextArea {
}

// Text / TextInput / TextEdit Shared Properties
text: "str"
color: "red" // text color
renderType: Text.QtRendering // Default given by QQuickWindow::textRenderType
contentHeight: 200 // height of the unclipped text
contentWidth: 200 // width of the unclipped text
bottomPadding: 1 // padding around the content, not part of contentHeight, overrides 'padding'
leftPadding: 1 // padding around the content, not part of contentWidth, overrides 'padding'
rightPadding: 1 // padding around the content, not part of contentWidth, overrides 'padding'
topPadding: 1 // padding around the content, not part of contentHeight, overrides 'padding'
padding: 1 // padding around the content, not part of contentHeight/contentHeight
font.bold: true
font.capitalization: Font.MixedCase // default, see QML font type for enums
font.family: "Helvetica"
font.hintingPreference: Font.PreferDefaultHinting // default, see QML font type for enums
font.italic: true
font.kerning: true // Whether to auto adjust character spacing, default enabled
font.letterSpacing: 1 // real, spacing between characters
font.pointSize 16 // real, device independent
font.pixelSize: 5 // Overrides pointSize, int, device dependent
font.preferShaping: true // Whether to enable display/spacing rules, default enabled
font.strikeout: true
font.underline: true
font.weight: Font.Normal // default, see QML font type for enums
font.wordSpacing: 1 // real, spacing between words
  
// Text / TextInput / TextEdit RenderType Enum
Text.QtRendering        // advanced features (transformations)
Text.NativeRendering    // look native on the target platform, no advanced features (transformations)  
  
// Text / TextInput / TextEdit Alignment Enums
Text.AlignLeft      TextInput.AlignLeft      TextEdit.AlignLeft
Text.AlignRight     TextInput.AlignRight     TextEdit.AlignRight
Text.AlignHCenter   TextInput.AlignHCenter   TextEdit.AlignHCenter
Text.AlignTop       TextInput.AlignTop       TextEdit.AlignTop
Text.AlignBottom    TextInput.AlignBottom    TextEdit.AlignBottom
Text.AlignVCenter   TextInput.AlignVCenter   TextEdit.AlignVCenter

// Text / TextInput / TextEdit  WrapMode Enum
Text.NoWrap             // no wrapping
Text.WordWrap           // wrapping done on word boundaries only
Text.WrapAnywhere       // wrapping is done at any point on a line, even in the middle of a word
Text.Wrap               // if possible, Text.WordWrap, else Text.WrapAnywhere
TextInput.NoWrap        // no wrapping
TextInput.WordWrap      // wrapping done on word boundaries only
TextInput.WrapAnywhere  // wrapping is done at any point on a line, even in the middle of a word
TextInput.Wrap          // if possible, TextInput.WordWrap, else TextInput.WrapAnywhere
TextEdit.NoWrap         // no wrapping
TextEdit.WordWrap       // wrapping done on word boundaries only
TextEdit.WrapAnywhere   // wrapping is done at any point on a line, even in the middle of a word
TextEdit.Wrap           // if possible, TextEdit.WordWrap, else TextEdit.WrapAnywhere

// TextInput InputMask Characters
A    // ASCII alphabetic character required. A-Z, a-z
a    // ASCII alphabetic character permitted but not required
N    // ASCII alphanumeric character required. A-Z, a-z, 0-9
n    // ASCII alphanumeric character permitted but not required
X    // Any character required
x    // Any character permitted but not required
9    // ASCII digit required. 0-9
0    // ASCII digit permitted but not required
D    // ASCII digit required. 1-9
d    // ASCII digit permitted but not required (1-9)
#    // ASCII digit or plus/minus sign permitted but not required
H    // Hexadecimal character required. A-F, a-f, 0-9
h    // Hexadecimal character permitted but not required
B    // Binary character required. 0-1
b    // Binary character permitted but not required
>    // All following alphabetic characters are uppercased
<    // All following alphabetic characters are lowercased
!    // Switch off case conversion
\    // To escape the special characters listed above to use them as separators

// TextInput InputMethodHints Flags
Qt.ImhNone                   // No hints
Qt.ImhHiddenText             // Characters should be hidden, auto set when echoMode is TextInput.Password
Qt.ImhSensitiveData          // Typed text should not be stored in persistent storage (dictionary lookup)
Qt.ImhNoAutoUppercase        // Should not try to auto switch to upper case when a sentence ends
Qt.ImhPreferNumbers          // Numbers are preferred (but not required)
Qt.ImhPreferUppercase        // Upper case letters are preferred (but not required)
Qt.ImhPreferLowercase        // Lower case letters are preferred (but not required)
Qt.ImhNoPredictiveText       // Do not use predictive text (dictionary lookup) while typing
Qt.ImhDate                   // The text editor functions as a date field
Qt.ImhTime                   // The text editor functions as a time field.
Qt.ImhMultiLine              // Don't stop input when Return or Enter key is pressed
Qt.ImhDigitsOnly             // Only digits are allowed
Qt.ImhFormattedNumbersOnly   // Only number input is allowed, includes decimal point and minus sign
Qt.ImhUppercaseOnly          // Only upper case letter input is allowed
Qt.ImhLowercaseOnly          // Only lower case letter input is allowed
Qt.ImhDialableCharactersOnly // Only characters suitable for phone dialing are allowed
Qt.ImhEmailCharactersOnly    // Only characters suitable for email addresses are allowed
Qt.ImhUrlCharactersOnly      // Only characters suitable for URLs are allowed

// TextInput EchoMode Enum
TextInput.Normal              // Displays the text as it is (default)
TextInput.Password            // Displays platform-dependent password mask characters instead
TextInput.NoEcho              // Displays nothing
TextInput.PasswordEchoOnEdit  // Displays characters as they are entered while editing, otherwise password

// TextInput SelectionMode Enum
TextInput.SelectCharacters    // Selects all characters between selection start/end pos
TextInput.SelectWords         // Selects all words between selection start/end pos, partial words included

// TextInput CursorPosition Enum
TextInput.CursorBetweenCharacters  // Returns the position between characters that is nearest x
TextInput.CursorOnCharacter        // Returns the position before the character that is nearest x

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML DYNAMIC CREATION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
// CREATE COMPONENT
// Returns a Component object created using qml url, parent can be null
// Use createObject to create an object instance of this component, will return null if failed
// incubator can be used to load instances asynchronously
var component = Qt.createComponent("MyQML.qml");
console.log(component.errorString());
if (component.status == Component.Ready) {
    var obj = component.createObject(parent, {"x": 100, "y": 100});
    var obj = component.createObject(parent, {"x": Qt.binding(function() { return item.x; })});
  
    var incubator = component.incubateObject(parent, { x: 10, y: 10 });
    if (incubator.status != Component.Ready) {
        incubator.onStatusChanged = function(status) {
            if (status == Component.Ready) {
                var obj = incubator.object;
            }
        }
    }
}

// Component State Enum
Component.Null     // no data is available for the component
Component.Ready    // the component has been loaded, and can be used to create instances
Component.Loading  // the component is currently being loaded
Component.Error    // an error occurred while loading the component

// CREATE QML OBJECT
// Will be null if error creating object
// Any imports used here must also be at top of file
var obj = Qt.createQmlObject('import QtQuick 2.0; Rectangle {width: 20; height: 20}', parent);

// LOADER
// Dynamic loading from a URL or Component
// If an explicit size is not set for Loader, automatically resized to the size of the loaded item
// Signals emitted from the loaded object can be received using the Connections type
// Use myLoader.item to access dynamic-created item
// If using external myComponent, it can only see properties in myLoader, not in any of myLoader parents
Loader {
    id: loader
    sourceComponent: component // set to undefined or change to destroy items
    sourceComponent: Component { } // Supports inline
    source: "MyItem.qml" // set to "" or change to destroy items
    focus: true // must be set to true for any of its children to get the active focus
    onLoaded: {} // Signal when loading complete
}
loader.active // Set to false destroys, doesn't auto create if source/sourceComponent changes, true creates
loader.asynchronous // Default false, change to false while loading will force it to finish synchronously
loader.item // Item loaded, not available until Loader.Ready state
loader.progress // Progress real [0.0, 1.0]
loader.status // Status enum value

// Loader State Enum
Loader.Null     // the loader is inactive or no QML source has been set
Loader.Ready    // the QML source has been loaded
Loader.Loading  // the QML source is currently being loaded
Loader.Error    // an error occurred while loading the QML source

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML VIEWS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ScrollView {
    Layout.fillWidth: true
    Layout.fillHeight: true
    ListView {
        id: listView
        Layout.fillWidth: true
        Layout.fillHeight: true
        model: context_model // Set through C++

        onCurrentIndexChanged: {
            console.log("Selected " + currentIndex);
        }          
        onCurrentItemChanged: {
            console.log("Selected " + currentItem);
        }
        
        // Each item of the model is instantiated with the delegate
        delegate: Item {
            property bool isHighlighted: mouseArea.containsMouse
            property bool isSelected: listView.currentIndex == index
            MouseArea {
                id: mouseArea
                anchors.fill: parent
                hoverEnabled: true
                acceptedButtons: Qt.RightButton | Qt.LeftButton
                onPressed: { listView.currentIndex = index; }
                onClicked: { listView.currentIndex = index; }
            }                   
            Text {
                width: listView.width
                height: 30
                text: role_name // Set through C++
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML INPUT HANDLING
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
ACTIVE FOCUS:
• Item currently receives keyboard input
• Or item is a FocusScope ancestor of the item that currently receives keyboard input

KEY HANDLING STEPS
1) Qt receives the key action and generates a key event
2) If a QQuickWindow is the active window, the key event is delivered to it
3) The key event is delivered to the Item with active focus. If none with focus then event ignored
4) If the Item accepts the key event, propagation stops
5) If the Item declines, the event is sent to the Item's parent until the event is accepted or root reached
**************************************************************************************************************/

// MOUSEAREA
// Inherits Item
MouseArea {
    acceptedButtons: Qt.LeftButton // default
    cursorShape: Qt.ArrowCursor // default
    drag.target: item // Item to drag
    drag.axis: Drag.XAxis // Axis mask
    drag.minimumX: 1.0 // how far the target can be dragged along the axis
    drag.maximumX: 1.0 // how far the target can be dragged along the axis
    drag.minimumY: 1.0 // how far the target can be dragged along the axis
    drag.maximumY: 1.0 // how far the target can be dragged along the axis
    drag.filterChildren: true // drag can override descendant MouseAreas, so parent can handle drag
    drag.threshold: 1 // determines the threshold in pixels of when the drag operation should start
    drag.smoothed: true // target will be moved only after the drag operation has started, default true
    enabled: true // overrides Item.enabled, only skips mouse events
    hoverEnabled: true // whether hover events are handled
    pressAndHoldInterval: // overrides the elapsed time in milliseconds before pressAndHold is emitted
    onPressed: {}
    onRelease: {}
    onClicked: {}
}
area.containsMouse // whether the mouse is currently inside the mouse area
area.containsPress // pressed && containsMouse
area.drag.active // if the target item is currently being dragged
area.mouseX // local to area, valid only on press, or if hover enabled, if cursor inside area
area.mouseY // local to area, valid only on press, or if hover enabled, if cursor inside area
area.pressed // whether any of the acceptedButtons are currently pressed
  
// MOUSE EVENT
// Use with MouseArea signals
mouse.accepted // Set to true to stop propagation to parent
mouse.button // button flag that caused the event, can't be Qt.AllButtons
mouse.buttons // for mouse move events, all button flags held down
mouse.modifiers // keyboard modifier flags
mouse.source // mouse event source enum
mouse.wasHeld // If the mouse button has been held pressed longer the threshold (800ms)
mouse.x // real, coordinate
mouse.y // real, coordinate

// KEY SIGNALS
// Add to any Item, to stop propagation, do event.accepted = true
Item {
    Keys.onPressed: {} // Handle key pressed event when has active focus
}

// KEY EVENT
// Use with Key signals
event.accepted // Set to true to stop propagation to parent
  
// SHORTCUT
Shortcut {
    autoRepeat: true // default true
    context: Qt.WindowShortcut // default
    sequence: StandardKey.Copy
    sequences: [StandardKey.Cut, StandardKey.Copy]
    onActivated: {}
}

// MOUSE BUTTON FLAGS
Qt.RightButton
Qt.LeftButton
Qt.MiddleButton
Qt.AllButtons

// MOUSE EVENT SOURCE ENUM
Qt.MouseEventNotSynthesized            // Actual mouse event from user
Qt.MouseEventSynthesizedBySystemn      // Synthesized from touch or tablet event
Qt.MouseEventSynthesizedByQt           // Synthesized from an unhandled touch or tablet event by Qt
Qt.MouseEventSynthesizedByApplication  // Synthesized by the application

// MOUSE DRAG AXIS MASK
Drag.XAxis
Drag.YAxis
Drag.XAndYAxis

// KEYBOARD MODIFIER FLAGS
Qt.NoModifier 
Qt.ShiftModifier  
Qt.ControlModifier
Qt.AltModifier     
Qt.MetaModifier   
Qt.KeypadModifier

// SHORTCUT CONTEXT ENUM
Qt.WindowShortcut       // Active when its parent item is in an active top-level window
Qt.ApplicationShortcut  // Active when one of the application's windows are active
  
// STANDARD KEY FLAGS
StandardKey.AddTab                     // Add new tab
StandardKey.Back                       // Navigate back
StandardKey.Backspace                  // Delete previous character
StandardKey.Bold                       // Bold text
StandardKey.Close                      // Close document/tab
StandardKey.Copy                       // Copy
StandardKey.Cut                        // Cut
StandardKey.Delete                     // Delete
StandardKey.DeleteEndOfLine            // Delete end of line
StandardKey.DeleteEndOfWord            // Delete word from the end of the cursor
StandardKey.DeleteStartOfWord          // Delete the beginning of a word up to the cursor
StandardKey.DeleteCompleteLine         // Delete the entire line
StandardKey.Find                       // Find in document
StandardKey.FindNext                   // Find next result
StandardKey.FindPrevious               // Find previous result
StandardKey.Forward                    // Navigate forward
StandardKey.HelpContents               // Open help contents
StandardKey.InsertLineSeparator        // Insert a new line
StandardKey.InsertParagraphSeparator   // Insert a new paragraph
StandardKey.Italic                     // Italic text
StandardKey.MoveToEndOfDocument        // Move cursor to end of document
StandardKey.MoveToEndOfLine            // Move cursor to end of line
StandardKey.MoveToNextChar             // Move cursor to next character
StandardKey.MoveToNextLine             // Move cursor to next line
StandardKey.MoveToNextPage             // Move cursor to next page
StandardKey.MoveToNextWord             // Move cursor to next word
StandardKey.MoveToPreviousChar         // Move cursor to previous character
StandardKey.MoveToPreviousLine         // Move cursor to previous line
StandardKey.MoveToPreviousPage         // Move cursor to previous page
StandardKey.MoveToPreviousWord         // Move cursor to previous word
StandardKey.MoveToStartOfDocument      // Move cursor to start of document
StandardKey.MoveToStartOfLine          // Move cursor to start of line
StandardKey.New                        // Create new document
StandardKey.NextChild                  // Navigate to next tab or child window
StandardKey.Open                       // Open document
StandardKey.Paste                      // Paste
StandardKey.Preferences                // Open the preferences dialog
StandardKey.PreviousChild              // Navigate to previous tab or child window
StandardKey.Print                      // Print document
StandardKey.Quit                       // Quit the application
StandardKey.Redo                       // Redo
StandardKey.Refresh                    // Refresh or reload current document
StandardKey.Replace                    // Find and replace
StandardKey.SaveAs                     // Save document after prompting the user for a file name
StandardKey.Save                       // Save document
StandardKey.SelectAll                  // Select all text
StandardKey.Deselect                   // Deselect text
StandardKey.SelectEndOfDocument        // Extend selection to end of document
StandardKey.SelectEndOfLine            // Extend selection to end of line
StandardKey.SelectNextChar             // Extend selection to next character
StandardKey.SelectNextLine             // Extend selection to next line
StandardKey.SelectNextPage             // Extend selection to next page
StandardKey.SelectNextWord             // Extend selection to next word
StandardKey.SelectPreviousChar         // Extend selection to previous character
StandardKey.SelectPreviousLine         // Extend selection to previous line
StandardKey.SelectPreviousPage         // Extend selection to previous page
StandardKey.SelectPreviousWord         // Extend selection to previous word
StandardKey.SelectStartOfDocumen       // Extend selection to start of document
StandardKey.SelectStartOfLine          // Extend selection to start of line
StandardKey.Underline                  // Underline text
StandardKey.Undo                       // Undo
StandardKey.UnknownKey                 // Unbound key
StandardKey.WhatsThis                  // Activate "what's this"
StandardKey.ZoomIn                     // Zoom in
StandardKey.ZoomOut                    // Zoom out
StandardKey.FullScreen                 // Toggle the window state to/from full screen
StandardKey.Cancel                     // Cancel the current operation

// CURSOR SHAPE ENUM
Qt.WaitCursor
Qt.IBeamCursor
Qt.SizeVerCursor
Qt.SizeHorCursor
Qt.SizeBDiagCursor
Qt.SizeFDiagCursor
Qt.SizeAllCursor
Qt.BlankCursor
Qt.SplitVCursor
Qt.SplitHCursor
Qt.PointingHandCursor
Qt.ForbiddenCursor
Qt.WhatsThisCursor
Qt.BusyCursor
Qt.OpenHandCursor
Qt.ClosedHandCursor
Qt.DragCopyCursor
Qt.DragMoveCursor
Qt.DragLinkCursor

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML GLOBAL ITEMS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
Qt.application.aboutToQuit.connect(mySlot) // Called on application exit
Qt.application.state // Read only application state enum, undefined without QGuiApplication
Qt.application.layoutDirection // Read only application layout enum, undefined without QGuiApplication
Qt.application.font // Read only default font from QGuiApplication::font, undefined without QGuiApplication
Qt.application.arguments // arguments the executable was invoked with
Qt.application.name // application name set on the QCoreApplication instance
Qt.application.displayName // application display name set on the QCoreApplication instance
Qt.application.version // application version set on the QCoreApplication instance
Qt.application.organization // organization name set on the QCoreApplication instance
Qt.application.domain // organization domain set on the QCoreApplication instance
Qt.application.supportsMultipleWindows // read only whether platform supports multiple windows
Qt.application.screens // array of QML Screen containing the descriptions of all connected screens  
Qt.platform.os // String name of platform
Qt.styleHints // QStyleHints, platform-specific style hints and settings
Qt.atob(data) // decodes the base64 encoded data string and returns it
Qt.btoa(data) // returns a base64 encoding of data
Qt.callLater(myFn, arg1, arg2...) // Call once the QML engine returns to the event loop
Qt.exit(returncode) // causes the QQmlEngine::exit(int) signal to be emitted
Qt.isQtObject(obj) // true if object is a valid reference to a Qt or QML object
Qt.md5(data) // Returns a hex string of the md5 hash of data
Qt.quit() // Quits the application

// APPLICATION STATE
Qt.ApplicationActive     // Top-most and focused, interactable
Qt.ApplicationInactive   // Not top-most or interactable but visible
Qt.ApplicationSuspended  // Not visible or running
Qt.ApplicationHidden     // Not visible but running
  
// APPLICATION LAYOUT
Qt.RightToLeft           // Text and graphics positioned right to left
Qt.LeftToRight           // Text and graphics positioned left to right

// PLATFORM TYPE
"android"   // Android
"ios"       // iOS
"linux"     // Linux
"osx"       // macOS
"unix"      // Other Unix-based OS
"windows"   // Windows

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEBUGGING QML
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
QT CREATOR QML DEBUGGING
1) In the Run Settings, Debugger Settings section, select the Enable QML 
2) Window > Output Panes > Debugger Console allows executing javascript during a break
3) Use the Locals and Expressions views to explore/change the QML item structure
 
PROFILING QML
1) Ensure project built with QML debugging infrastructure
2) Run: app.exe -qmljsdebugger=port:<port>
3) Should output: QML Debugger: Waiting for connection on port <port>
4) Enter console command: qmlprofiler -p <port> -attach <ip address>
**************************************************************************************************************/

QML_IMPORT_TRACE // enable debug output from QML's import loading 
QT_DECLARATIVE_DEBUG / QT_QML_DEBUG // enable the debugging infrastructure

console.log("Message")
console.debug("Message")
console.info("Message")
console.warn("Message")
console.error("Message")
console.assert(exp, "Message on fail")
console.time("timerName") / console.timeEnd("timerName") // log the time (in milliseconds) between the calls
console.trace() // prints stack trace
console.profile() / console.profileEnd() 
console.exception("Message") // prints message and stack trace
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML OPTIMIZATIONS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
PROPERTY OPTIMIZATIONS:
• Avoid declaring with var keyword unless type is QVariantMap/variant
• Using a propery resolves it; faster to store result in local and access that
      var rectColor = rect.color; // resolve the common base.
      printValue("red", rectColor.r);
      printValue("green", rectColor.g)
• Avoid lots of writes to Q_PROPERTIES especially if has notify signal, pefer temp while initialising
      var tempProperty = [];
      tempProperty.length = 100;
      for (var i = 0; i < 100; ++i) {
          tempProperty[i] = i;
      }
      qProperty = tempProperty;
• Avoid binding as container[index] as it will re-evaluate when any container member is changed, do instead
      property int intermediateBinding: cointainer[index]
      property int firstBinding: intermediateBinding + x;
      property int secondBinding: intermediateBinding + y;

PROPERTY BINDING OPTIMZATIONS:
• Avoid declaring intermediate JavaScript variables
• Avoid accessing "var" properties
• Avoid calling JavaScript functions
• Avoid constructing closures or defining functions within the binding expression
• Avoid accessing properties outside of the immediate evaluation scope (non-component properties)
• Avoid writing to other properties
• Prefer binding to anchors over using another component's height/width properties

JAVASCRIPT OPTIMIZATIONS:
• Avoid using eval() if at all possible
• Do not delete properties of objects

COMPONENT OPTIMIZATIONS:
• If a component has a custom property, it becomes its own implicit type. 
  If more than one of these used, move to own file to save memory
• Consider using an asynchronous Loader component
• Prefer Item over invisible Rectangles
• For global data, use singleton types instead of pragma library scripts
  
RENDERING OPTIMIZATIONS:
• Set asynchronous property of images to true for loading
• Set sourceSize property for images to the exact size you want to ensure only what's needed is cached
• Avoid smoothing images using the smooth property
• May be better to disable bindings before and animation and re-enable once finished
• Avoid running JavaScript during animation
• Avoid enabling clipping
• Opaque faster than translucent, only one pixel needed to be considered translucent

MODEL/VIEW OPTIMIZATIONS
• Use WorkerScript with ListModel to move processing to another thread if needed
• Avoid setting the ListModel dynamicRoles property to true
• Avoid using ShaderEffect elements within delegates
• Never enable clipping on a delegate
• Use view cacheBuffer property to allow asynchronous creation and buffering of
  delegates outside of the visible area, at a memory usage increase cost
**************************************************************************************************************/
