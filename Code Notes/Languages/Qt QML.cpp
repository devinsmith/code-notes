/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QT MODELING LANGUAGE (QML)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
QML MEMORY ALLOCATION
• Using QML allocates both in C++ heap and javascript garbage collected heap
• WorkerScripts share their own seperate Javascript heap, only allocated if WorkerScript is used
• Adding custom properties makes it an implicit type of the component (allocates memory for new type) 
• Not adding custom properties makes it an explicit type of the component (shares memory for type)

C++ HEAP ALLOCATIONS:
• Overhead of the QML engine (implementation data structures, context information)
• Per-component compiled data and type information, depending which modules/components used
• Per-object C++ data/property values, plus metaobject hierarchy, depending which modules/components used
• Any data which is allocated specifically by QML libraries

JAVASCRIPT HEAP ALLOCATIONS:
• Javascript engine itself including built in types
• Javascript integration: constructor functions for loaded types, function templates
• Variables allocated during expression evaluation
• Per-type layout information and other internal type-data generated by the JavaScript engine at runtime
• Per-object JavaScript data: var properties, functions/signal handlers, non-optimized binding expressions

QML SCENE GRAPH
• Low-level, high-performance rendering stack that renders QML visual items using OpenGL by default
• Allows the scene to be retained between frames and complete set of primitives is known before rendering
• Allows optimizations such as batch rendering to minimize state changes and discarding obscured primitives
• Managed and rendered by the QQuickWindow class 
• Three render loop types: Basic/Windows uses main thread, Threaded uses dedicated thread
• Render loop type auto chosen for hardware, usually Threaded, QSG_RENDER_LOOP forces type
  
SCENE GRAPH NODES
• Added by subclassing QQuickItem::updatePaintNode and setting the QQuickItem::ItemHasContents flag
• Only use classes with the "QSG" prefix inside the QQuickItem::updatePaintNode
• To preprocess, set QSGNode::UsePreprocess and override QSGNode::preprocess; called before rendering
• Each node uses a material (simple OpenGL shader program)

SCENE GRAPH NODE TYPES:
QSGClipNode           Implements the clipping functionality in the scene graph
QSGGeometryNode       Used for all rendered content, describes the shape/mesh of the primitive
QSGNode               The base class for all nodes in the scene graph
QSGOpacityNode        Used to change opacity of nodes
QSGTransformNode      Implements transformations in the scene graph
QSGSimpleRectNode     QSGGeometryNode which defines a rectangular geometry with a solid color material
QSGSimpleTextureNode  QSGGeometryNode which defines a rectangular geometry with a texture material

SCENE GRAPH THREADED RENDER LOOP:
1) QQuickItem::update called when QML scene changed
2) Render thread prepares to draw a new frame
3) Meanwhile GUI thread calls QQuickItem::updatePolish to do final item touch-up
4) GUI thread is blocked
5) QQuickWindow::beforeSynchronizing signal is emitted
6) Synchronization of the QML state into the scene graph by calling QQuickItem::updatePaintNode
7) GUI thread block is released
8) The scene graph is rendered:
     1) QQuickWindow::beforeRendering signal is emitted
     2) QSGNode::preprocess called for those that use it
     3) Renderer processes the nodes and calls OpenGL functions
     4) QQuickWindow::afterRendering signal is emitted
     5) Rendered frame is swapped and QQuickWindow::frameSwapped is emitted
9) Meanwhile GUI is free to advance animations, process events, etc
**************************************************************************************************************/
    
import QtQuick 2.6
import QtQuick.Controls 1.4
import MyEnums 1.0    // Requires registering with QQmlEngine
import MyGlobals 1.0  // Requires registering with QQmlEngine
import "MyJavascript.js" as MyJS
  
// ITEM
// Base for most QML components, instantiates QQuickItem
Item {
    id: item                               // unique id of item, can be used to access it
    property int myProperty: 0             // custom property
    property int myProperty: myProperty2   // if myProperty2 changes, re-evaluates myProperty
    property int myProperty: myFunction    // if properties used in function changes, re-evaluates myProperty
    property int myProperty: { return 0; } // if properties used in function changes, re-evaluates myProperty
    property int myProperty: MyJS.fn       // Use function from imported javascript file
    property int myProperty: MyGlobal.fn   // Use function from singleton, Requires registering with QQmlEngine
    property int myProperty: MyEnum.ONE    // Use int type for enums, Requires registering with QQmlEngine
    property var myProperty: myObj         // Context Q_OBJECT, Requires registering with QQuickView
    property int myProperty: myObj.value   // Context Q_OBJECT with Q_PROPERTY 'value' with NOTIFY
    readonly property int myProperty: 0    // read-only property
    property alias myAlias: myProperty     // reference for property    
    signal mySignal(int value)             // call with item.mySignal(0)
      
    /* Attached Property, Called when the item has been instantiated */
    Component.onCompleted: {}

    /* Attached Property, Called when the item is destroyed */
    Component.onDestruction: {}

    /* Called when property has changed, for context Q_OBJECTs emit signal needed */
    onMyPropertyChanged: {}
  
    /* Called when signal emitted, 'value' arg passed in */
    onMySignal: { value }
  
    /* Called when signal emitted, requires calling signal.connect */
    function mySlot(value) {}

    /* Javascript custom function */
    function myFunction(x, y) {
        return x + y;
    }
  
    /* Item states, if multiple 'when' true, first is chosen */
    states: [
        State {
            name: "state1" 
            PropertyChanges { target: item; myProperty: 1 } 
            when: myBoolProperty
        },
        State { 
            name: "state2" 
            PropertyChanges { target: item; myProperty: 2 }
            when: myFunction
        }
    ]  
}
item.mySignal.connect(mySlot) // Connect signal and slot
item.activeFocus // Read only, whether item has active focus
item.activeFocusOnTab // Whether included in active focus on tab, default false
item.antialiasing // Whether antialiasing enable, default false
item.baselineOffset // Position offset, default 0, used for text
item.childrenRect // Read only, QML rect collective position and size of the item's children
item.clip // Whether clipping enabled, default false, hides part of item/children, performance hit
item.enabled // Recursive, whether the item receives mouse and keyboard events
item.focus // Whether item has input focus
item.height // Actual height of item
item.width // Actual width of item
item.implicitHeight // Default height of the Item if no height is specified
item.implicitWidth // Default width of the Item if no width is specified
item.opacity // Alpha of item, values outside [0,1] clamped
item.objectName // Inherited from QObject
item.parent // returns Item, visual parent of the item
item.rotation // rotation of the item in degrees clockwise around its transformOrigin, default 0
item.scale // size of item, negative mirror's item, default 1
item.smooth // Image interpolation, true is linear, false is nearest neighbour, default true
item.transformOrigin // TransformOrigin type which scale/rotate use
item.visible // Recursive, whether item is rendered
item.x / item.y / item.z // Position and stacking depth of item, negative z draws under parent
item.anchors // Sub options: top, bottom, left, right, horizontalCenter, verticalCenter, baseLine
item.anchors.fill // Takes QML Item parent or sibling, set to undefined to detach
item.anchors.centerIn // Takes QML Item parent or sibling, set to undefined to detach
item.anchors.margins // Set value for all margins
item.anchors.topMargin // Set value for top margin
item.anchors.bottomMargin // Set value for bottom margin
item.anchors.leftMargin // Set value for left margin
item.anchors.rightMargin // Set value for right margin
item.anchors.horizontalCenterOffset // Value offset from horizontal center
item.anchors.verticalCenterOffset // Value offset from vertical center
item.anchors.baselineOffset // Value offset from position
item.anchors.alignWhenCentered // forces centered anchors to align to a whole pixel, default true
item.data // list<Object> of both visual children and resources
item.layer.effect // Component, typically a ShaderEffect component
item.layer.enabled // Whether the item is layered or not, disabled by default
item.layer.format // Enum, internal OpenGL format of the texture
item.layer.mipmap // Whether mipmaps are generated for the texture
item.layer.samplerName // Name of the effect's source texture property
item.layer.samples // Enum, allows requesting multisampled rendering in the layer
item.layer.smooth // Whether the layer is smoothly transformed
item.layer.sourceRect // The rectangular area of the item that should be rendered into the texture
item.layer.textureMirroring // Enum, how the generated OpenGL texture should be mirrored
item.layer.textureSize // Pixel size of the layers texture, if empty (default) uses item's size
item.layer.wrapMode // Enum, OpenGL wrap modes associated with the texture
item.resources // list<Object>, contains non-visual children
item.state // QString state name, default empty
item.states // list<State>, list of possible states for this item
item.transform // list<Transform>, list of transformations to apply
item.transitions // list<Transition>, transitions to be applied to the item whenever it changes its state
item.visibleChildren // list<Item>, contains visual children
item.childAt(x, y) // Returns first visible QML Item child found at point within item coord system
item.contains(point) // If item contains QML point (in local coordinates)
item.forceActiveFocus(reason) // Focuses item and any parent FocusScopes, reason optional
item.grabToImage(callback, targetSize) // Grabs the item into an in-memory image
item.grabToImage(function(result) { result.saveToFile("/Folder/image.png"); }) // Save as image
item.mapFromGlobal(x, y) // Converts global coords into item local coords, retuns QML point
item.mapFromItem(item2, x, y, w, h) // Converts item2 local coords into item local coords, retuns QML rect
item.mapFromItem(item2, x, y) // Converts item2 local coords into item local coords, retuns QML point
item.mapToGlobal(x, y) // Converts item local coords into global coords, returns QML point
item.mapToItem(item2, x, y, w, h) // Converts item local coords into item2 local coords, returns QML rect
item.mapToItem(item2, x, y) // Converts item local coords into item2 local coords, returns QML point
item.nextItemInFocusChain(forward) // Returns item next in the focus chain, forward optional

// MyGlobal.qml
// Requires registering with QQmlEngine
pragma Singleton
import QtQuick 2.4
QtObject {
    property value: 0
    function fn() {
        return 0;
    }
}

// MyJavascript.js
// Make a library to enable sharing across all QML files
var value = 0;
function fn() {
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML BASIC TYPES
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
property bool myBool: true
property double myDouble: 0.0
property int myInt: 0
property real myReal: 0.0

// VAR
// Use for holding Javascript types, QVariantMap and variant
// Object attributes do not send signal or update bindings when changed
property var myFn: (function() { return 0; }) // Javascript function
property var myArray: [1, 2, 3, "a", "b"] // Javascript array
property var myObj: { "a":0, "b":1 } // Javascript object
property var myObj: ({ a:0, b:1 }) // Javascript object, requires () without "
property var myObj: new Object({ "a":0, "b":1 }) // Javascript object
property int myAttr: myObj.a // Will not update when 'a' updates

// LIST
// list of QML objects, not a Javascript array
// Auto converts to/from QmlListProperty
property list myList
myList.length // item count in list
myList[index] // access item
  
// POINT
// Auto converts to/from QPoint and QPoint
// Attributes do not have signals, use onMyPointChanged instead
property point myPoint: Qt.point(0, 20)
property point myPoint: "0,20"
myPoint.x / myPoint.y
  
// RECT
// Auto converts to/from QRect and QRectF
// Attributes do not have signals, use onMyRectChanged instead
property rect myRect: "50,50,100x100"
property rect myRect: Qt.rect(50, 50, 100, 100)
myRect.x / myRect.y
myRect.width
myRect.height
myRect.top // read-only
myRect.bottom // read-only
myRect.left // read-only
myRect.right // read-only

// SIZE
// Auto converts to/from QSize and QSizeF
// Attributes do not have signals, use onMySizeChanged instead
property size mySize: "150x50"
property size mySize: Qt.size(150, 50)
mySize.width
mySize.height

// URL
// Auto converts to/from QUrl
property url myUrl: "folder/image.png" // Relative path, will be converted to absolute
property url myUrl: "file:///folder/image.png" // Absolute path
property url myUrl: "qrc:///folder/image.png" // Resource path
myUrl == Qt.resolvedUrl("folder/image.png") // Comparison
myUrl.toString() // Returns the absolute path
Qt.resolvedUrl(myUrl) // Returns url resolved relative to the URL of the caller

// STRING
// Auto converts to/from QString
// Attributes do not have signals, use onMyStrChanged instead
property string myStr: "str"
myStr.length
Qt.qsTrId(id) // returns translated string at id, else id if no translation
Qt.qsTrIdNoOp(id) // Marks id for dynamic translation, returns id

//===========================================================================================================
// QML DATE
//===========================================================================================================

// DATE
// Auto converts to/from QDate and QDateTime
property date myDate: "2020-12-31"
  
// Takes JavaScript Date or QML date, returns date as string
// Format defaults Qt.SystemLocaleShortDate, can be Date Format Enum or Date Format String
Qt.formatDate(date, format)
Qt.formatDateTime(date, format)
Qt.formatTime(date, format)
  
// Date Format Enum
Qt.TextDate                // ddd MMM d yyyy
Qt.ISODate                 // yyyy-MM-dd or yyyy-MM-ddTHH:mm:ss or with a time-zone suffix 
Qt.ISODateWithMs           // Qt.ISODate with ms
Qt.SystemLocaleShortDate   // The short format used by the operating system
Qt.SystemLocaleLongDate    // The long format used by the operating system
Qt.DefaultLocaleShortDate  // The short format specified by the application's locale
Qt.DefaultLocaleLongDate   // The long format specified by the application's locale
  
// Date Format String
// Can use space . and : to seperate (eg. "ddd MMMM d yy" )
d     // the day as number without a leading zero (1 to 31)
dd    // the day as number with a leading zero (01 to 31)
ddd   // the abbreviated localized day name (e.g. 'Mon' to 'Sun'). Uses QDate::shortDayName()
dddd  // the long localized day name (e.g. 'Monday' to 'Qt::Sunday'). Uses QDate::longDayName()
M     // the month as number without a leading zero (1-12)
MM    // the month as number with a leading zero (01-12)
MMM   // the abbreviated localized month name (e.g. 'Jan' to 'Dec'). Uses QDate::shortMonthName()
MMMM  // the long localized month name (e.g. 'January' to 'December'). Uses QDate::longMonthName()
yy    // the year as two digit number (00-99)
yyyy  // the year as four digit number
h     // the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
hh    // the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
m     // the minute without a leading zero (0 to 59)
mm    // the minute with a leading zero (00 to 59)
s     // the second without a leading zero (0 to 59)
ss    // the second with a leading zero (00 to 59)
z     // the milliseconds without leading zeroes (0 to 999)
zzz   // the milliseconds with leading zeroes (000 to 999)
AP    // use AM/PM display. AP will be replaced by either "AM" or "PM"
ap    // use am/pm display. ap will be replaced by either "am" or "pm"
t     // include a time-zone indicator

//===========================================================================================================
// QML COLOR
//===========================================================================================================

// COLOR
// ARGB color value, auto converts to/from QColor
// Attributes do not have signals, use onMyColorChanged instead
property color myColor: "red"
property color myColor: "#RRGGBB"
property color myColor: "#AARRGGBB"
property color myColor: Qt.rgba(r, g, b, a) // All real in range [0.0,1.0]
Qt.hsva(hue, saturation, value, alpha) // All real in range [0.0,1.0]
Qt.hsla(hue, saturation, lightness, alpha) // All real in range [0.0,1.0]
Qt.darker(myColor, v) // Returns darker color by converting to HSV then value/v, v <= 0 unspecified
Qt.darker(myColor) // Returns color 50% darker than myColor
Qt.lighter(myColor, v) // Returns lighter color by converting to HSV then value*v, v <= 0 unspecified
Qt.lighter(myColor) // Returns color 50% lighter than myColor
Qt.tint(myColor, tintColor) // Returns color with tintColor overlaying myColor
Qt.colorEqual(myColor, myColor2) // Either argument can be Color or string type
myColor.r / myColor.g / myColor.b / myColor.a
myColor.hsvHue
myColor.hsvSaturation
myColor.hsvValue 
myColor.hslHue
myColor.hslSaturation
myColor.hslLightness

// PALETTE
// Each property is QML color
property palette myPalette
myPalette.alternateBase // Alternate background color in item views with alternating row colors
myPalette.base // Background color for text editor controls and items views
myPalette.brightText // Text color that contrasts well with palette.dark, used on  highlighted buttons
myPalette.button // General button background color
myPalette.buttonText // Foreground color used with the palette.button color
myPalette.dark // Darker than palette.button
myPalette.highlight // Color to indicate a selected item or the current item
myPalette.highlightedText // Text color that contrasts with palette.highlight
myPalette.light // Lighter than palette.button
myPalette.link // Text color used for hyperlinks
myPalette.linkVisited // Text color used for already visited hyperlinks
myPalette.mid // Between palette.button and palette.dark
myPalette.midlight // Between palette.button and palette.light
myPalette.shadow // A very dark color
myPalette.text // Foreground color used with palette.base
myPalette.toolTipBase // Used as the background color for tooltips
myPalette.toolTipText // Used as the foreground color for tooltips
myPalette.window // General background color
myPalette.windowText // General foreground color

//===========================================================================================================
// QML MATH
//===========================================================================================================

// MATRIX4X4
// Attributes do not have signals, use onMyMatChanged instead
property matrix4x4 myMat: Qt.matrix4x4(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
myMat.m11...myMat.m44
myMat.column(index) // returns vector4d, zero-based index
myMat.determinant() // returns real
myMat.fuzzyEquals(myMat2, epsilon) // epsilon is real
myMat.inverted() // returns myMat inverted
myMat.minus(myMat2) // myMat - myMat2
myMat.plus(myMat2) // myMat + myMat2
myMat.row(index) // returns vector4d, zero-based index
myMat.times(myMat2) // multiplying myMat with myMat4
myMat.times(myVec) // transforming vector3d or vector4d with the 4x4 matrix
myMat.times(value) // multiply matrix by real scalar
myMat.toString()
myMat.transposed() // returns myMat transposed

// QUATERNION
// Attributes do not have signals, use onMyQuatChanged instead
property quaternion myQuat: "1.0,0,1,0" // scalar,x,y,z
property quaternion myQuat: Qt.quaternion(1.0,0,1,0) // scalar,x,y,z
myQuat.x / myQuat.y / myQuat.z
myQuat.scalar

// VECTOR2D
// Attributes do not have signals, use onMyVecChanged instead
property vector2d myVec: "0,1"
property vector2d myVec: Qt.vector2d(0,1)
myVec.x / myVec.y
myVec.dotProduct(myVec2) // returns real
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector3d() // returns vector3d, z component is set to 0
myVec.toVector4d() // returns vector4d, z/w components set to 0
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

// VECTOR3D
// Attributes do not have signals, use onMyVecChanged instead
property vector3d myVec: "0,1,0"
property vector3d myVec: Qt.vector3d(0,1,0)
myVec.x / myVec.y / myVec.z
myVec.crossProduct(myVec2) // returns vector x vector2
myVec.dotProduct(myVec2) // returns real
myVec.times(matrix) // transforming vector with the 4x4 matrix
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector2d() // returns vector2d, z component dropped
myVec.toVector4d() // returns vector4d, w component set to 0
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

// VECTOR4D
// Attributes do not have signals, use onMyVecChanged instead
property vector4d myVec: "0,1,0,1"
property vector4d myVec: Qt.vector3d(0,1,0,1)
myVec.x / myVec.y / myVec.z / myVec.w
myVec.dotProduct(myVec2) // returns real
myVec.times(matrix) // transforming vector with the 4x4 matrix
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector2d() // returns vector2d, z/w components dropped
myVec.toVector3d() // returns vector3d, w component dropped
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

//===========================================================================================================
// QML FONT
//===========================================================================================================

// FONT
// Auto converts to/from QFont
// If no matching font exists, Qt will use the closest matching installed font
// Attributes do not have signals, use onMyFontChanged instead
property font myFont: Qt.font({ family: "Helvetica", weight: Font.Black })
Qt.fontFamilies() // Returns list<string> of font families available
myFont.family // String font family name
myFont.bold // Whether bold
myFont.italic // Whether italic
myFont.underline // Whether has underline
myFont.pointSize // real, device independent
myFont.pixelSize // Overrides pointSize, int, device dependent
myFont.weight // Font Weighting Enum
myFont.overline // Whether has overline
myFont.strikeout // Whether line through it
myFont.capitalization // Font Capitalization Enum
myFont.letterSpacing // real, spacing between characters
myFont.wordSpacing // real, spacing between words
myFont.kerning // Whether to auto adjust character spacing, default enabled
myFont.preferShaping // Whether to enable display/spacing rules, default enabled
myFont.hintingPreference // Font Hinting Enum

// Font Weighting Enum
Font.Thin          Font.Normal       Font.Bold       
Font.ExtraLight    Font.Medium       Font.ExtraBold  
Font.Light         Font.DemiBold     Font.Black
  
// Font Capitalization Enum
Font.MixedCase       // No change
Font.AllUppercase    // Render in all uppercase
Font.AllLowercase    // Render in all lowercase
Font.SmallCaps       // Render in all small-caps
Font.Capitalize      // Render with the first character of each word as uppercase
  
// Font Hinting Enum
// Adjusts an outline (non-rastor) font so it lines up with a rasterized grid
// Important for displaying small text, only used with "NativeRendering"
Font.PreferDefaultHinting    // default hinting level
Font.PreferNoHinting         // render text without hinting
Font.PreferVerticalHinting   // no horizontal hinting, but align in the vertical direction
Font.PreferFullHinting       // hinting in both horizontal and vertical directions

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML LAYOUTS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// LAYOUT ATTACHED PROPERTIES
// Use these on any components inside the layout
Layout.alignment // Layout Alignment Flags
Layout.bottomMargin // Overrides margin property if set
Layout.column // column position of an item in a GridLayout
Layout.columnSpan // column span of an item in a GridLayout
Layout.fillHeight // Uses preferredHeight if false
Layout.fillWidth // Uses preferredWidth if false
Layout.leftMargin // Overrides margin property if set
Layout.margins // Spacing between items
Layout.maximumHeight // Number.POSITIVE_INFINITY default
Layout.maximumWidth // Number.POSITIVE_INFINITY default
Layout.minimumHeight // 0 default
Layout.minimumWidth // 0 default
Layout.preferredHeight // if -1 (default), will be ignored, and item's implicitHeight used instead
Layout.preferredWidth // if -1 (default), will be ignored, and item's implicitWidth used instead
Layout.rightMargin // Overrides margin property if set
Layout.row // row position of an item in a GridLayout
Layout.rowSpan // row span of an item in a GridLayout
Layout.topMargin // Overrides margin property if set

// Layout Alignment Flags
Qt.AlignLeft       Qt.AlignTop
Qt.AlignHCenter    Qt.AlignVCenter
Qt.AlignRight      Qt.AlignBottom
Qt.AlignBaseline

// ROWLAYOUT
// Inherits Item, Aligns elements after each other in a single row
RowLayout {
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

// COLUMNLAYOUT
// Inherits Item, Aligns elements after each other in a single column
ColumnLayout {
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

// GRIDLAYOUT
// Inherits Item, Aligns elements in a grid with n columns
GridLayout {
    columns: 3
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML COMPONENTS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// QTOBJECT
// lightweight non-visual element
QtObject {
   objectName: "name"
}

// COMPONENT
// Instantiates QQmlComponent, Used for sourceComponent and contentItem properties
Component {
    Rectangle {
        signal mySignal(int value)
    }
}

// CONNECTIONS
// Access a signal outside of the object that emits it, required for Loader items
Connections {
    target: loader.item
    onMySignal: { value }
}

// BINDING
// Will become active and assign value to myProperty when myBoolean becomes true
// When active, will disable any direct bindings myProperty may have until myBoolean is false
Binding {
    target: item // required if not a child of item with property
    property: "myProperty" // can be QML basic type attribute (eg. "myRectProperty.x")
    when: myBoolean
    value: 10 // Can be value, another property etc
    delayed: true // wait until event queue cleared before assigning
}

// REPEATER
// Inherits Item, Usually in Row/Column, instantiates n items
// creates all of its delegate items when the repeater is first created
Repeater {
    id: repeater
    model: 3
    Text { text: "Item " + indeX + "/" + repeater.count }
}
Repeater {
    model: ["one", "two", "three"]
    Text { text: "Data: " + modelData }
}
Repeater {
    model: listView
    Text { text: "Data: " + modelData.role_name }
}

// TIMER
// Triggers a handler at a specified interval
Timer {
    interval: 500 // milliseconds
    running: true
    repeat: true
    triggeredOnStart: true // default false, triggered signal emitted once extra on timer start
    onTriggered: {}
}
timer.restart()
timer.start()
timer.stop()
  
// RECTANGLE
// Inherits Item
Rectangle {
    color: "red"
    radius: 2
    antialiasing: true // Default true if using radius, false otherwise, gives performance hit
    border.color: "red"
    border.width: 1
    gradient: Gradient {}
}

// GRADIENT
Gradient {
}

// INTVALIDATOR
// Instantiates QIntValidator
IntValidator {
    bottom: -1 // default -infinity
    top: 1 // default infinity
} 
  
// DOUBLEVALIDATOR
// Instantiates QDoubleValidator
DoubleValidator {
    bottom: -1.0 // default -infinity
    top: 1.0 // default infinity
    decimals: 1 // n digits after decimal point, default 1000
    notation: DoubleValidator.ScientificNotation // default 
}
DoubleValidator.StandardNotation     // disables E in value
DoubleValidator.ScientificNotation   // allow E in value
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML ACTIONS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
// ACTION
// Inherits QtObject, used in AbstractButton
Action {
    ActionGroup.group: myAction // Add the action to the group
    checkable: true // defaults false
    checked: true
    icon.width: 100 // maximum width of the icon
    icon.height: 100 // maximum height of the icon
    icon.color: "red" // tints with colour    
    icon.source: "qrc:///icon.png"
    text: "str"
    shortcut: StandardKey.Copy
    onTriggered: { source }
    onToggled: { source }
}
action.toggle(source) // Toggle the action/emit signal, source defaults to null
action.trigger(source) // Trigger the action/emit signal, source defaults to null

// ACTIONGROUP
// Inherits QtObject, Groups actions together
// Can add items as children, through ActionGroup.group attached property or addAction()
ActionGroup {
    Action { checkable: true } // Add action as children, 'checkable' required
    checkedAction: myAction // Currently selected/checked action
    enabled: true // False disables all actions, true enables except for those explicity disabled
    exclusive: true // Default true, if false checkedAction is always null
    onTriggered: { action } // When an action is triggered
}
group.actions // list<Action> of actions
group.addAction(myAction) // Add an action
group.removeAction(myAction) // Remove an action

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML CONTROLS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CONTROL
// Inherits Item, base class for all controls
// Controls (except non-interactive indicators) do not let clicks/touches through to children
Control {
    bottomPadding: 1 // padding around the contentItem, overrides 'padding'
    leftPadding: 1 // padding around the contentItem, overrides 'padding'
    rightPadding: 1 // padding around the contentItem, overrides 'padding'
    topPadding: 1 // padding around the contentItem, overrides 'padding'
    padding: 1 // padding around the contentItem
    background: Rectangle {}
    contentItem: Label {} // Item automatically resized to fit within the padding of the control
    focusPolicy: Qt.NoFocus // Control Focus Policy Enum, the way the control accepts focus
    font: Qt.font() // QML font used
    hoverEnabled: true // Whether the control accepts hover events
    locale: Locale {} // Locale specific properties for formatting data and numbers
    mirrored: true // Whether the control is mirrored
    spacing: 1.0 // Spacing for control, each derived class uses it differently
    wheelEnabled: true // Whether the control handles wheel events, default false
}
control.availableHeight // Height available to the contentItem after deducting vertical padding
control.availableWidth // Width available to the contentItem after deducting horizontal padding
control.focusReason // Holds the reason of the last focus change, Input Focus Reason enum
control.hovered // Whether the control is hovered
control.palette // QML palette used for control, default application palette, changing also changes children
control.visualFocus // If has activefocus and with FocusReason Tab, Backtab or Shortcut

// Control Focus Policy Enum
Qt.TabFocus     // The control accepts focus by tabbing
Qt.ClickFocus   // The control accepts focus by clicking
Qt.StrongFocus  // The control accepts focus by both tabbing and clicking
Qt.WheelFocus   // The control accepts focus by tabbing, clicking, and using the mouse wheel
Qt.NoFocus      // The control does not accept focus

// COMBOBOX
// Inherits Control, Combined button and popup list for selecting options
ComboBox {
}

// SPINBOX
// Inherits Control, Allows the user to select from a set of preset values
SpinBox {
}

// DIAL
// Inherits Control, Circular dial that is rotated to set a value
Dial {
}

// BUSYINDICATOR
// Inherits Control, Indicates background activity
BusyIndicator {
}

// PROGRESSBAR
// Inherits Control, Indicates the progress of an operation
ProgressBar {
}

// SLIDER
// Inherits Control, Used to select a value by sliding a handle along a track
Slider {
}

// RANGESLIDER
// Inherits Control, Used to select a range of values by sliding two handles along a track
RangeSlider {
}

// TUMBLER
// Inherits Control, Spinnable wheel of items that can be selected
Tumbler {
}

// SCROLLBAR
// Inherits Control, Vertical or horizontal interactive scroll bar
ScrollBar {
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML BUTTONS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ABSTRACTBUTTON
// Inherits Control, base class for all buttons
AbstractButton {
    text: "str"
    action: myAction
    autoExclusive: true // checkable btns with same parent auto-group, doesn't affect if part of ButtonGroup
    checkable: true // defaults false
    checked: true
    display: AbstractButton.IconOnly // Abstract Button Display Enum
    icon.width: 100 // maximum width of the icon
    icon.height: 100 // maximum height of the icon
    icon.color: "red" // tints with colour    
    icon.source: "qrc:///icon.png"
    onCanceled: {} // When loses mouse grab when pressed or not inside button when released emitted
    onClicked: {} // When button is clicked by user via touch, mouse or keyboard
    onDoubleClicked: {} // When button is double clicked by user via touch or mouse
    onPressAndHold: {} // When the button is pressed and held down by user via touch or mouse
    onPressed: {} // When button is pressed by user via touch, mouse, or keyboard
    onReleased: {} // When button is released by user via touch, mouse, or keyboard
    onToggled: {} // When checkable button is toggled by the user via touch, mouse, or keyboard
}
button.down // Whether button visually down
button.pressed // Read-only, whether button visually down
button.toggle() // Toggles the checked state of the button

// Abstract Button Display Enum
AbstractButton.IconOnly	
AbstractButton.TextOnly
AbstractButton.TextBesideIcon

// BUTTON
// Inherits AbstractButton
Button {
}

// ROUNDBUTTON
// Inherits AbstractButton, Button with rounded corners
RoundButton {
}

// CHECKBOX
// Inherits AbstractButton
CheckBox {
}

// RADIOBUTTON
// Inherits AbstractButton, Exclusive radio button that can be toggled on or off
RadioButton {
}

// TABBUTTON
// Inherits AbstractButton, Button with a look suitable for a TabBar
TabButton {
}

// SWITCH
// Inherits AbstractButton, Switch button that can be toggled on or off
Switch {
}

// MENUITEM
// Inherits AbstractButton
MenuItem {
}

// BUTTONGROUP
// Inherits QtObject, Mutually-exclusive group of checkable buttons
ButtonGroup {
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML CONTAINERS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CONTAINER
// Inherits Control, Abstract base class for some containers
Container {
}

// FLICKABLE
// Inherits Item, Provides a surface that can be "flicked"
Flickable {
    ScrollBar.vertical: ScrollBar { } // Add a vertical scrollbar
    ScrollBar.horizontal: ScrollBar { } // Add a horizontal scrollbar
}

// PANE
// Inherits Control, Provides a background matching with the application style and theme
Pane {
}

// FRAME
// Inherits Pane, Visual frame for a logical group of controls
Frame {
}

// SCROLLVIEW
// Inherits Control, Auto uses Flickable if child has one
ScrollView {
}

// SWIPEVIEW
// Inherits Container, Enables the user to navigate pages by swiping sideways
SwipeView {
}

// MENUBAR
// Inherits Container, Provides a window menu bar
MenuBar {
}

// TABBAR
// Inherits Container, Allows the user to switch between different views or subtasks
TabBar {
}

// TOOLBAR
// Inherits Pane, Container for context-sensitive controls
ToolBar {
}

// GROUPBOX
// Inherits Frame, Visual frame and title for a logical group of controls
GroupBox {
}

// SPLITVIEW
// No QML Controls 2 version, need to copy from version 1 as just inherits Item
SplitView {
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML POPUPS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// POPUP
// Inherits QtObject, base class for all popups
Popup {
    visible: false // Turning on/off will show popup window
    title: "Title"
    width: 300
    height: 80
    contentItem: Rectangle {}
}

// DIALOG
// Inherits Popup
Dialog {
}

// MENU
// Inherits Popup, Call using id.popup() to show at mouse position
Menu {
    visible: false // context menu start off invisible
    MenuSeparator { visible: true }
    MenuItem { text: "str" }
}

// TOOLTIP
// Inherits Popup, Provides tool tips for any control
ToolTip {
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML TEXT
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// TEXT / TEXTINPUT / TEXTEDIT SHARED PROPERTIES
{
    text: "str"
    color: "red" // text color
    renderType: Text.QtRendering // RenderType Enum, Default given by QQuickWindow::textRenderType
    contentHeight: 200 // height of the unclipped text
    contentWidth: 200 // width of the unclipped text
    bottomPadding: 1.0 // padding around the content, not part of contentHeight, overrides 'padding'
    leftPadding: 1.0 // padding around the content, not part of contentWidth, overrides 'padding'
    rightPadding: 1.0 // padding around the content, not part of contentWidth, overrides 'padding'
    topPadding: 1.0 // padding around the content, not part of contentHeight, overrides 'padding'
    padding: 1.0 // padding around the content, not part of contentHeight/contentHeight
    font.bold: true
    font.capitalization: Font.MixedCase // default, see QML font type for enums
    font.family: "Helvetica"
    font.hintingPreference: Font.PreferDefaultHinting // default, see QML font type for enums
    font.italic: true
    font.kerning: true // Whether to auto adjust character spacing, default enabled
    font.letterSpacing: 1 // real, spacing between characters
    font.pointSize 16 // real, device independent
    font.pixelSize: 5 // Overrides pointSize, int, device dependent
    font.preferShaping: true // Whether to enable display/spacing rules, default enabled
    font.strikeout: true
    font.underline: true
    font.weight: Font.Normal // default, see QML font type for enums
    font.wordSpacing: 1 // real, spacing between words
}

// TEXTLINE
// lineLaidOut signal object
line.number // Read-only property
line.x / line.y // Can modify to change position of line
line.width // Can modify to change width of line
line.height // Can modify to change height of line 

// TEXT
// Inherits item, Styled text label
Text {
    wrapMode: Text.NoWrap // default, Wrap Mode Enum
    horizontalAlignment: Text.AlignHCenter // Alignment Enum
    verticalAlignment: Text.AlignVCenter // Alignment Enum
    baseUrl: "http://qt-project.org/" // Used to resolve relative URLs within the text (eg. images/logo.png)
    clip: true // Whether the text is clipped
    elide: Text.ElideNone // default, Elide Mode Enum
    fontSizeMode: Text.FixedSize // default, Font Size Mode Enum
    hoveredLink: "" // link string when the user hovers a link embedded in the text
    lineHeight: 1.0 // Text line height, in pixels or a multiplier depending on lineHeightMode
    lineHeightMode: Text.ProportionalHeight // default, Line Height Mode Enum
    linkColor: "red" // Color of links in the text, RichText unsupported
    maximumLineCount: 1 // Limit the number of lines that the text item will show, RichText unsupported
    minimumPixelSize: 1 // Minimum font pixel size, requires !Text.FixedSize and font.pixelSize != -1
    minimumPointSize: 1 // Minimum font point size, requires !Text.FixedSize and font.pointSize != -1
    style: Text.Normal // Text Style Enum
    styleColor: "red" // Color used depending on style property
    textFormat: Text.PlainText // Text Format Enum
    onLineLaidOut: { line } // Emitted for each line of text that is laid out during the layout process
    onLinkActivated: { link } // when the user clicks on a link embedded in the text, link is string
    onLinkHovered: { link } // when the user hovers on a link embedded in the text, link is string    
}
text.advance // pixel distance from first char of text to first char of another Text if in a text flow
text.lineCount // Number of lines visible in the text item
text.truncated // If the text has been truncated due to maximumLineCount or elid, RichText unsupported
text.forceLayout() // Triggers a re-layout of the displayed text
text.linkAt(x, y) // Returns ink string at point x, y in content coordinates, empty if nothing there

// TEXTINPUT
// Inherits Item, single line of editable plain text
TextInput {
    wrapMode: TextInput.NoWrap // default, Wrap Mode Enum
    horizontalAlignment: TextInput.AlignHCenter // Alignment Enum
    verticalAlignment: TextInput.AlignVCenter // Alignment Enum
    displayText: "str" // Dependent on echo mode, holds input as editing    
    activeFocusOnPress: true // If gain active focus on a mouse press
    autoScroll: true
    cursorDelegate: Rectangle {} // Override cursor
    echoMode: TextInput.Normal // Echo Mode Enum
    inputMask: ">AAAAA-AAAAA-AAAAA;#" // Input Mask Characters
    inputMethodHints: Qt.ImhDigitsOnly | Qt.ImhTime // Input Method Hints Flags
    validator: myValidator
    maximumLength: 100 // truncates/prevents input, default 32767
    mouseSelectionMode: TextInput.SelectCharacters // Requires selectByMouse true, Selection Mode Enum
    overwriteMode: true // Whether text inserted will overrite (insert key behavior)
    passwordCharacter: "*" // Character used with echomode Password, only first char is used
    passwordMaskDelay: 10 // ms delay before masking the character for echomode Password
    persistentSelection: true // Whether keep selection when focus lost, default false
    readOnly: true
    selectByMouse: true // Allow mouse to select, default false
    selectedTextColor: "red" // text
    selectionColor: "red" // background
    onAccepted: {} // when Return/Enter key pressed and text passed validation
    onEditingFinished: {} // when Return/Enter key pressed or focus lost and text passed validation
    onTextEdited: {} // whenever the text is edited by user, not explicitly set
}
input.acceptableInput // if validator/input mask has been set, true if valid, if not set, always true
input.canUndo // If writable and there are previous operations that can be undone
input.canPaste // If writable and the content of the clipboard can be pasted into input
input.canRedo // If writable and there are undone operations that can be redone
input.cursorPosition // position of the cursor in input
input.cursorRectangle // rectangle where the cursor is rendered within input
input.cursorVisible // True when input shows a cursor
input.length // Length of text, if has inputMask will include mask characters
input.preeditText // partial text input from an input method
input.selectedText // currently selected text
input.selectionEnd // index after last character where selection ends in 'text', read-only
input.selectionStart // index of first character where selection starts in 'text', read-only
input.clear() // clears text
input.copy() // Copies selected text to system clipboard, won't work for Password echomode
input.cut() // Cuts selected text to system clipboard, won't work for Password echomode
input.deselect() // Removes selection
input.ensureVisible(position) // Scrolls the contents to position
input.getText(start, end) // Returns section of text between start and end positions
input.insert(position, "str") // Inserts at position
input.isRightToLeft(start, end) // true if natural reading direction between start/end is right to left
input.moveCursorSelection(position, selectionMode) // Moves cursor and selects while moving
input.paste() // Replaces the currently selected text by the contents of the system clipboard
input.positionAt(x, y, cursorPosition) // Returns position from topleft of input based on Cursor Position Enum
input.positionToRectangle(position) // Returns QML rect that cursor would occupy if placed at char position
input.redo() // Redos if possible
input.remove(start, end) // Removes section of text between start and end position
input.select(start, end) // Selects start to end char position, if out of range does no selection change
input.selectAll() // Causes all text to be selected
input.selectWord() // Selects word closest to the current cursor position
input.undo() // Undos if possible

// TEXTEDIT
// Inherits Item, multiple lines of editable formatted text
// Requires Flickable or ScrollView to implement scrolling, following the cursor etc
TextEdit {
    wrapMode: TextEdit.NoWrap // default, Wrap Mode Enum
    horizontalAlignment: TextEdit.AlignHCenter // Alignment Enum
    verticalAlignment: TextEdit.AlignVCenter // Alignment Enum
    activeFocusOnPress: true // If gain active focus on a mouse press
    baseUrl: "http://qt-project.org/" // Used to resolve relative URLs within the text (eg. images/logo.png)
    cursorDelegate: Rectangle {} // Override cursor
    hoveredLink: "" // link string when the user hovers a link embedded in the text
    inputMethodComposing: true // whether the textedit has partial text input from an input method
    inputMethodHints: Qt.ImhDigitsOnly | Qt.ImhTime // Input Method Hints Flags
    mouseSelectionMode: TextInput.SelectCharacters // Requires selectByMouse true, Selection Mode Enum
    overwriteMode: true // Whether text inserted will overrite (insert key behavior)
    persistentSelection: true // Whether keep selection when focus lost, default false
    readOnly: true
    selectByKeyboard: true // User can use the keyboard to select text, default false if read-only
    selectByMouse: true // Allow mouse to select, default false
    selectedTextColor: "red" // text
    selectionColor: "red" // background
    tabStopDistance: 1.0 // default distance, in device units, between tab stops
    textFormat: TextEdit.PlainText // Text Format Enum
    onEditingFinished: {} // when the text edit loses focus
    onLinkActivated: { link } // when the user clicks on a link embedded in the text, link is string
    onLinkHovered: { link } // when the user hovers on a link embedded in the text, link is string
}
edit.canUndo // If writable and there are previous operations that can be undone
edit.canPaste // If writable and the content of the clipboard can be pasted into textedit
edit.canRedo // If writable and there are undone operations that can be redone
edit.cursorPosition // position of the cursor in textedit, Cursor Position Enum
edit.cursorRectangle // rectangle where the cursor is rendered within textedit
edit.cursorVisible // True when textedit shows a cursor
edit.length // Length of text
edit.lineCount // Total amount of lines in textedit
edit.preeditText // partial text input from an input method
edit.selectedText // currently selected text
edit.selectionEnd // index after last character where selection ends in 'text', read-only
edit.selectionStart // index of first character where selection starts in 'text', read-only
edit.textDocument // Returns QQuickTextDocument, can be used to implement syntax highlighting
edit.append("str") // Appends a new paragraph to text
edit.clear() // clears text
edit.copy() // Copies selected text to system clipboard
edit.cut() // Cuts selected text to system clipboard
edit.deselect() // Removes selection
edit.getFormattedText(start, end) // Returns formatted section of text between start/end positions
edit.getText(start, end) // Returns section of text between start/end positions
edit.insert(position, "str") // Inserts at position
edit.isRightToLeft(start, end) // true if natural reading direction between start/end is right to left
edit.linkAt(x, y) // Returns ink string at point x, y in content coordinates, empty if nothing there
edit.moveCursorSelection(position, selectionMode) // Moves cursor and selects while moving
edit.paste() // Replaces the currently selected text by the contents of the system clipboard
edit.positionAt(x, y, cursorPosition) // Returns position from topleft of input based on cursorPosition
edit.positionToRectangle(position) // Returns QML rect that cursor would occupy if placed at char position
edit.redo() // Redos if possible
edit.remove(start, end) // Removes section of text between start and end position
edit.select(start, end) // Selects start to end char position, if out of range does no selection change
edit.selectAll() // Causes all text to be selected
edit.selectWord() // Selects word closest to the current cursor position
edit.undo() // Undos if possible
 
// LABEL
// Inherits Text, Styled text label
Label {
    background: Rectangle {} // If no size set, auto follows the control's size, must set implicit sizes
}
lbl.palette // QML palette used for control, default application palette

// TEXTFIELD
// Inherits TextInput, Displays a single line of editable plain text
TextField {
    background: Rectangle {} // If no size set, auto follows the control's size, must set implicit sizes
    hoverEnabled: true // Whether the control accepts hover events
    placeholderText: "str" // Text shown before user inputs
    onPressAndHold: { event } // MouseEvent given on a long press
    onPressed: { event } // MouseEvent given on press
    onReleased: { event } // MouseEvent given on release
}
field.focusReason // Holds the reason of the last focus change, Input Focus Reason enum
field.hovered // Whether the control is hovered
field.palette // QML palette used for control, default application palette
  
// TEXTAREA
// Inherits TextEdit, Displays multiple lines of editable formatted text
TextArea {
    background: Rectangle {} // If no size set, auto follows the control's size, must set implicit sizes
    hoverEnabled: true // Whether the control accepts hover events
    placeholderText: "str" // Text shown before user inputs
    onPressAndHold: { event } // MouseEvent given on a long press
    onPressed: { event } // MouseEvent given on press
    onReleased: { event } // MouseEvent given on release
}
area.focusReason // Holds the reason of the last focus change, Input Focus Reason enum
area.hovered // Whether the control is hovered
area.palette // QML palette used for control, default application palette

// TEXTMETRICS
// Provides metrics for a given font and text
TextMetrics {
    text: "str"
}
metrics.advanceWidth // Distance from the position of str where the next string should be drawn in pixels
metrics.boundingRect // Bounding rectangle of str
metrics.elide // Elide Mode Enum
metrics.elideWidth // Largest width str can have in pixels before eliding will occur
metrics.elidedText // Elided version of the string
metrics.font // QML font used for the metrics calculations
metrics.height // Height of the bounding rectangle
metrics.tightBoundingRect // Tight bounding rectangle of str
metrics.width // Width of the bounding rectangle
  
// Text / TextInput / TextEdit RenderType Enum
Text.QtRendering        // advanced features (transformations)
Text.NativeRendering    // look native on the target platform, no advanced features (transformations)  
  
// Text / TextInput / TextEdit Alignment Enum
Text.AlignLeft      TextInput.AlignLeft      TextEdit.AlignLeft
Text.AlignRight     TextInput.AlignRight     TextEdit.AlignRight
Text.AlignHCenter   TextInput.AlignHCenter   TextEdit.AlignHCenter
Text.AlignTop       TextInput.AlignTop       TextEdit.AlignTop
Text.AlignBottom    TextInput.AlignBottom    TextEdit.AlignBottom
Text.AlignVCenter   TextInput.AlignVCenter   TextEdit.AlignVCenter

// Text / TextInput / TextEdit Wrap Mode Enum
Text.NoWrap             // no wrapping
Text.WordWrap           // wrapping done on word boundaries only
Text.WrapAnywhere       // wrapping is done at any point on a line, even in the middle of a word
Text.Wrap               // if possible, Text.WordWrap, else Text.WrapAnywhere
TextInput.NoWrap        // no wrapping
TextInput.WordWrap      // wrapping done on word boundaries only
TextInput.WrapAnywhere  // wrapping is done at any point on a line, even in the middle of a word
TextInput.Wrap          // if possible, TextInput.WordWrap, else TextInput.WrapAnywhere
TextEdit.NoWrap         // no wrapping
TextEdit.WordWrap       // wrapping done on word boundaries only
TextEdit.WrapAnywhere   // wrapping is done at any point on a line, even in the middle of a word
TextEdit.Wrap           // if possible, TextEdit.WordWrap, else TextEdit.WrapAnywhere

// Text / TextMetrics Elide Mode Enum
Qt.ElideNone            // No eliding
Qt.ElideLeft            // For example: "...World"
Qt.ElideMiddle          // For example: "He...ld"
Qt.ElideRight           // For example: "Hello..."

// Text / TextEdit Text Format Enum
// PlainText/StyledText offer better performance at cost of formatting
TextEdit.AutoText       // Will auto determine whether text should be treated as rich text
TextEdit.PlainText      // Contains no formatting, only line breaks and spacing
TextEdit.RichText       // Contains formatting (font sizes, colors, bolding, italics etc)
Text.AutoText           // Will auto determine whether text should be treated as rich text
Text.PlainText          // Contains no formatting, only line breaks and spacing
Text.RichText           // Contains formatting (font sizes, colors, bolding, italics etc)
Text.StyledText         // Optimized RichText format with some formatting 

// TextInput / TextEdit Selection Mode Enum
TextInput.SelectCharacters    // Selects all characters between selection start/end pos
TextInput.SelectWords         // Selects all words between selection start/end pos, partial words included
TextEdit.SelectCharacters     // Selects all characters between selection start/end pos
TextEdit.SelectWords          // Selects all words between selection start/end pos, partial words included

// TextInput / TextEdit Input Method Hints Flags
Qt.ImhNone                   // No hints
Qt.ImhHiddenText             // Characters should be hidden, auto set when echoMode is TextInput.Password
Qt.ImhSensitiveData          // Typed text should not be stored in persistent storage (dictionary lookup)
Qt.ImhNoAutoUppercase        // Should not try to auto switch to upper case when a sentence ends
Qt.ImhPreferNumbers          // Numbers are preferred (but not required)
Qt.ImhPreferUppercase        // Upper case letters are preferred (but not required)
Qt.ImhPreferLowercase        // Lower case letters are preferred (but not required)
Qt.ImhNoPredictiveText       // Do not use predictive text (dictionary lookup) while typing
Qt.ImhDate                   // The text editor functions as a date field
Qt.ImhTime                   // The text editor functions as a time field.
Qt.ImhMultiLine              // Don't stop input when Return or Enter key is pressed
Qt.ImhDigitsOnly             // Only digits are allowed
Qt.ImhFormattedNumbersOnly   // Only number input is allowed, includes decimal point and minus sign
Qt.ImhUppercaseOnly          // Only upper case letter input is allowed
Qt.ImhLowercaseOnly          // Only lower case letter input is allowed
Qt.ImhDialableCharactersOnly // Only characters suitable for phone dialing are allowed
Qt.ImhEmailCharactersOnly    // Only characters suitable for email addresses are allowed
Qt.ImhUrlCharactersOnly      // Only characters suitable for URLs are allowed

// TextInput Input Mask Characters
A    // ASCII alphabetic character required. A-Z, a-z
a    // ASCII alphabetic character permitted but not required
N    // ASCII alphanumeric character required. A-Z, a-z, 0-9
n    // ASCII alphanumeric character permitted but not required
X    // Any character required
x    // Any character permitted but not required
9    // ASCII digit required. 0-9
0    // ASCII digit permitted but not required
D    // ASCII digit required. 1-9
d    // ASCII digit permitted but not required (1-9)
#    // ASCII digit or plus/minus sign permitted but not required
H    // Hexadecimal character required. A-F, a-f, 0-9
h    // Hexadecimal character permitted but not required
B    // Binary character required. 0-1
b    // Binary character permitted but not required
>    // All following alphabetic characters are uppercased
<    // All following alphabetic characters are lowercased
!    // Switch off case conversion
\    // To escape the special characters listed above to use them as separators

// TextInput Echo Mode Enum
TextInput.Normal              // Displays the text as it is (default)
TextInput.Password            // Displays platform-dependent password mask characters instead
TextInput.NoEcho              // Displays nothing
TextInput.PasswordEchoOnEdit  // Displays characters as they are entered while editing, otherwise password

// TextInput Cursor Position Enum
TextInput.CursorBetweenCharacters  // Returns the position between characters that is nearest x
TextInput.CursorOnCharacter        // Returns the position before the character that is nearest x

// Text Font Size Mode Enum
Text.FixedSize       // The size specified by font.pixelSize or font.pointSize is used
Text.HorizontalFit   // Largest size up to set max that fits the width of the item without wrapping is used
Text.VerticalFit     // Largest size up to set max that fits the height of the item is used
Text.Fit             // Largest size up to set max that fits within the width/height of the item is used

// Text Line Height Mode Enum
Text.ProportionalHeight  // Use a multiplier for line height (eg. 2.0 doubles height)
Text.FixedHeight         // Use a fixed pixel height

// Text Style Enum
Text.Normal      Text.Raised
Text.Outline     Text.Sunken

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML ANIMATION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// TRANSITION
// Defines animated transitions that occur on state changes
Transition {
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML DYNAMIC CREATION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
// CREATE COMPONENT
// Returns a Component object created using qml url, parent can be null
// Use createObject to create an object instance of this component, will return null if failed
// incubator can be used to load instances asynchronously
var component = Qt.createComponent("MyQML.qml");
console.log(component.errorString());
if (component.status == Component.Ready) {
    var obj = component.createObject(parent, {"x": 100, "y": 100});
    var obj = component.createObject(parent, {"x": Qt.binding(function() { return item.x; })});
  
    var incubator = component.incubateObject(parent, { x: 10, y: 10 });
    if (incubator.status != Component.Ready) {
        incubator.onStatusChanged = function(status) {
            if (status == Component.Ready) {
                var obj = incubator.object;
            }
        }
    }
}

// Component State Enum
Component.Null     // no data is available for the component
Component.Ready    // the component has been loaded, and can be used to create instances
Component.Loading  // the component is currently being loaded
Component.Error    // an error occurred while loading the component

// CREATE QML OBJECT
// Will be null if error creating object
// Any imports used here must also be at top of file
var obj = Qt.createQmlObject('import QtQuick 2.0; Rectangle {width: 20; height: 20}', parent);

// LOADER
// Dynamic loading from a URL or Component
// If an explicit size is not set for Loader, automatically resized to the size of the loaded item
// Signals emitted from the loaded object can be received using the Connections type
// Use myLoader.item to access dynamic-created item
// If using external myComponent, it can only see properties in myLoader, not in any of myLoader parents
Loader {
    id: loader
    sourceComponent: component // set to undefined or change to destroy items
    sourceComponent: Component { } // Supports inline
    source: "MyItem.qml" // set to "" or change to destroy items
    focus: true // must be set to true for any of its children to get the active focus
    onLoaded: {} // Signal when loading complete
}
loader.active // Set to false destroys, doesn't auto create if source/sourceComponent changes, true creates
loader.asynchronous // Default false, change to false while loading will force it to finish synchronously
loader.item // Item loaded, not available until Loader.Ready state
loader.progress // Progress real [0.0, 1.0]
loader.status // Status enum value

// Loader State Enum
Loader.Null     // the loader is inactive or no QML source has been set
Loader.Ready    // the QML source has been loaded
Loader.Loading  // the QML source is currently being loaded
Loader.Error    // an error occurred while loading the QML source

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QT MODELS / VIEWS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*************************************************************************************************************
• Model: Contains the data and its structure
• View: A container that displays the data. The view might display the data in a list or a grid.
• Delegate: Determines how each element of data should appear in the view. Can also access each element.
• Role: Used to access different attributes of a data element in the model
**************************************************************************************************************/

ScrollView {
    Layout.fillWidth: true
    Layout.fillHeight: true 
    ListView {
        id: listView
        Layout.fillWidth: true
        Layout.fillHeight: true
        model: context_model // Set through C++

        onCurrentIndexChanged: {
            console.log("Selected " + currentIndex);
        }          
        onCurrentItemChanged: {
            console.log("Selected " + currentItem);
        }
        
        // Each item of the model is instantiated with the delegate
        delegate: Item {
            id: del
            property bool isHighlighted: mouseArea.containsMouse
            property bool isSelected: listView.currentIndex == index
            property bool isSelected: ListView.isCurrentItem // Alternative
              
            MouseArea {
                id: mouseArea
                anchors.fill: parent
                hoverEnabled: true
                acceptedButtons: Qt.RightButton | Qt.LeftButton
                onPressed: { listView.currentIndex = index; }
                onClicked: { listView.currentIndex = index; }
            }                   
            Text {
                width: listView.width
                height: 30
                text: role_name // Set through C++
            }
        }
    }
}

//===========================================================================================================
// QML VIEWS
//===========================================================================================================

// LISTVIEW
// Inherits Flickable, Display items from a model in a list
// Delegates are instantiated as needed and may be destroyed at any time
ListView {
    add: Transition {} // Used when item is added to view (but not on init/model change)
    addDisplaced: Transition {} // Used when items are displaced when item is added to view
    displaced: Transition {} // Used when items are displaced, overridden by addDisplaced etc.
    cacheBuffer: 20 // Explicitly set the buffer size for caching delegates outside the view
    currentIndex: 0 // Index of currently selected item, -1 is no selection
    currentSection: "section1" // Section that is currently at the beginning of the view
    effectiveLayoutDirection: Qt.LeftToRight // default, View Layout Direction Enum
    delegate: Component {} // Template defining each item instantiated by the view
    footer: Component {} // Component to use as the footer
    footerItem: Item {} // Item to use as the footer
    footerPositioning: ListView.InlineFooter // ListView Footer Positioning Enum
    header: Component {} // Component to use as the header
    headerItem: Item {} // Item to use as the header
    headerPositioning: ListView.InlineHeader // ListView Header Positioning Enum
    highlight: Component {} // Only creates one which follows selected item
    highlightItem: Item {} // Only creates one which follows selected item
    highlightFollowsCurrentItem: true // Whether highlight positioning is managed by view
    highlightMoveDuration: -1 // Default -1, take as many seconds as needed
    highlightMoveVelocity: 400 // Default 400 pixels/second
    highlightRangeMode: ListView.NoHighlightRange // Default, ListView Highlight Range Enum
    highlightResizeDuration:
    highlightResizeVelocity:
    keyNavigationEnabled:
    keyNavigationWraps:
    layoutDirection:
    model:
    move:
    moveDisplaced:
    orientation:
    populate:
    preferredHighlightBegin:
    preferredHighlightEnd:
    remove:
    removeDisplaced:
    section.property:
    section.criteria:
    section.delegate:
    section.labelPositioning:
    snapMode:
    spacing:
    verticalLayoutDirection:    
}
view.count // Number of items in the view
view.currentItem // Currently selected Item, null is no selection

// GRIDVIEW
// Inherits Flickable, Display items from a model in a grid
GridView {
}

// PATHVIEW
// Inherits Item, Lays out model-provided items on a path
PathView {
}

// View Layout Direction Enum
Qt.LeftToRight   // Items will be laid out from left to right
Qt.RightToLeft   // Items will be laid out from right to left
  
// ListView Header/Footer Positioning Enum
ListView.InlineFooter    // Positioned at the end, connected/will move as a normal item
ListView.OverlayFooter   // Positioned at the end, won't move
ListView.PullBackFooter  // Positioned at the end, can be pushed/pulled
ListView.InlineHeader    // Positioned at the start, connected/will move as a normal item
ListView.OverlayHeader   // Positioned at the start, won't move
ListView.PullBackHeader  // Positioned at the start, can be pushed/pulled

// ListView Highlight Range Enum
ListView.ApplyRange            // Can move outside of range at the end of list or due to mouse interaction
ListView.StrictlyEnforceRange  // Never move outside range, changes selected item if outside range
ListView.NoHighlightRange      // No range used


//===========================================================================================================
// QML DELEGATES
//===========================================================================================================

// DELEGATE PROPERTIES
// Given to any delegate Item, don't have to use ItemDelegate type
Item {
    ListView.onAdd: {} // Emitted immediately after an item is added to the view
    ListView.onRemove: {} // Emitted immediately before an item is removed from the view
    GridView.onAdd: {} // Emitted immediately after an item is added to the view
    GridView.onRemove: {} // Emitted immediately before an item is removed from the view  
} 
del.model // Role data for each delegate item, eg. model.role_name
del.modelData // If view's model has no roles, use to access item data for delegate
del.index // Index in view, can be -1 if removed from view
del.ListView.view // Use to access listView if delegate created outside it
del.ListView.isCurrentItem // Whether the delegate is the currently selected item
del.ListView.delayRemove // Whether the delegate has to delay destruction (eg. to finish animation)
del.ListView.nextSection // Section property name string of the next item
del.ListView.previousSection  // Section property name string of the previous item
del.ListView.section // Section property name of the item
del.GridView.view // Use to access gridView if delegate created outside it
del.GridView.isCurrentItem // Whether the delegate is the currently selected item
del.GridView.delayRemove // Whether the delegate has to delay destruction (eg. to finish animation)
del.PathView.view // Use to access pathView if delegate created outside it
del.PathView.isCurrentItem // Whether the delegate is the currently selected item
del.PathView.onPath // Whether the item is currently on the path

// ITEMDELEGATE
// Inherits AbstractButton, Basic item delegate
ItemDelegate {
    highlighted: ListView.isCurrentItem // set whether the delegate is highlighted
}

// CHECKDELEGATE
// Inherits ItemDelegate, has check indicator that can be toggled on or off
CheckDelegate {
}

// RADIODELEGATE
// Inherits ItemDelegate, has radio indicator that can be toggled on or off
RadioDelegate {
}

// SWITCHDELEGATE
// Inherits ItemDelegate, has a switch indicator that can be toggled on or off
SwitchDelegate {
}

// SWIPEDELEGATE
// Inherits ItemDelegate, Swipable item delegate
SwipeDelegate {
}

//===========================================================================================================
// QML MODELS
//===========================================================================================================

// LISTMODEL
// free-form list data source
ListModel {
}

// XMLLISTMODEL
// read-only model using XPath expressions
XmlListModel {
}

// OBJECTMODEL
// Defines a set of items to be used as a model
ObjectModel {
}

// ITEMSELECTIONMODEL
// Instantiates QItemSelectionModel, Allows keeping the selection state of multiple views in sync
// QML views do not use QModelIndex, need to convert to it when using ItemSelectionModel
ItemSelectionModel {
}
var modelIndex = model.index(view.currentIndex, 0) // Get QModelIndex from view
ism.select(modelIndex, ItemSelectionModel.Select | ItemSelectionModel.Current)
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML INPUT HANDLING
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
Qt.Key            http://doc.qt.io/qt-5/qt.html#Key-enum
StandardKey.Key   http://doc.qt.io/qt-5/qkeysequence.html#StandardKey-enum

TAB STOP: The location the cursor stops after the tab key is pressed
ACTIVE FOCUS: Item or FocusScope child currently receiving keyboard input

COMPOSED MOUSE EVENT:
• Clicked, doubleClicked and pressAndHold, composed of basic mouse events like pressed
• Changing the accepted property of the mouse parameter has no effect unless propagateComposedEvents true

KEY HANDLING STEPS:
1) Qt receives the key action and generates a key event
2) If a QQuickWindow is the active window, the key event is delivered to it
3) The key event is delivered to the Item with active focus. If none with focus then event ignored
4) If the Item accepts the key event, propagation stops
5) If the Item declines, the event is sent to the Item's parent until the event is accepted or root reached
**************************************************************************************************************/

// FOCUSSCOPE
FocusScope {
}

// MOUSEAREA
// Inherits Item
MouseArea {
    acceptedButtons: Qt.LeftButton // default
    cursorShape: Qt.ArrowCursor // default
    drag.target: item // Item to drag
    drag.axis: Drag.XAxis // Axis mask
    drag.minimumX: 1.0 // how far the target can be dragged along the axis
    drag.maximumX: 1.0 // how far the target can be dragged along the axis
    drag.minimumY: 1.0 // how far the target can be dragged along the axis
    drag.maximumY: 1.0 // how far the target can be dragged along the axis
    drag.filterChildren: true // drag can override descendant MouseAreas, so parent can handle drag
    drag.threshold: 1 // determines the threshold in pixels of when the drag operation should start
    drag.smoothed: true // target will be moved only after the drag operation has started, default true
    enabled: true // overrides Item.enabled, only skips mouse events
    hoverEnabled: true // whether hover events are handled
    pressAndHoldInterval: // overrides the elapsed time in milliseconds before pressAndHold is emitted
    preventStealing: true // prevents mouse events being stolen from area by parent, default false
    propagateComposedEvents: true // sends composed events to overlapping areas in lower visual stack order
    scrollGestureEnabled: true // whether responds to scroll gestures from non-mouse device, default true
    onCanceled: {} // When another item stole the mouse event handling
    onClicked: { mouse } // Composed event, Press and release both inside area
    onDoubleClicked: { mouse } // Composed event, Press followed by a release followed by a press
    onEntered: {} // Only on press unless hoved enabled, then on enter of area
    onExit: {} // Only on press unless hoved enabled, then on exit of area
    onPositionChanged: { mouse } // Only on press unless hoved enabled, then on mouse move in area
    onPressed: { mouse } // On press
    onPressAndHold: { mouse } // Composed event, press longer than 800 ms
    onReleased: { mouse } // On release 
    onWheel: { wheel } // Mouse wheel and trackpad scroll gestures
}
area.containsMouse // whether the mouse is currently inside the mouse area
area.containsPress // pressed && containsMouse
area.drag.active // if the target item is currently being dragged
area.mouseX // local to area, valid only on press, or if hover enabled, if cursor inside area
area.mouseY // local to area, valid only on press, or if hover enabled, if cursor inside area
area.pressed // whether any of the acceptedButtons are currently pressed
area.pressedButtons // mouse buttons currently pressed, can't be Qt.AllButtons

// KEYS
// Add to any Item, each signal has key event
Item {
    Keys.enabled: true // enable signals for this item, default true
    Keys.forwardTo: [item1, item2] // forwards event to each item, once accepted stops forwarding
    Keys.onAsteriskPressed: { event }
    Keys.onBackPressed: { event }
    Keys.onBacktabPressed: { event }
    Keys.onCallPressed: { event }
    Keys.onCancelPressed: { event }
    Keys.onContext1Pressed: { event }
    Keys.onContext2Pressed: { event }
    Keys.onContext3Pressed: { event }
    Keys.onContext4Pressed: { event }
    Keys.onDeletePressed: { event }
    Keys.onDigit0Pressed: { event }
    Keys.onDigit1Pressed: { event }
    Keys.onDigit2Pressed: { event }
    Keys.onDigit3Pressed: { event }
    Keys.onDigit4Pressed: { event }
    Keys.onDigit5Pressed: { event }
    Keys.onDigit6Pressed: { event }
    Keys.onDigit7Pressed: { event }
    Keys.onDigit8Pressed: { event }
    Keys.onDigit9Pressed: { event }
    Keys.onDownPressed: { event }
    Keys.onEnterPressed: { event }
    Keys.onEscapePressed: { event }
    Keys.onFlipPressed: { event }
    Keys.onHangupPressed: { event }
    Keys.onLeftPressed: { event }
    Keys.onMenuPressed: { event }
    Keys.onNoPressed: { event }
    Keys.onPressed: { event }
    Keys.onReleased: { event }
    Keys.onReturnPressed: { event }
    Keys.onRightPressed: { event }
    Keys.onSelectPressed: { event }
    Keys.onShortcutOverride: { event }
    Keys.onSpacePressed: { event }
    Keys.onTabPressed: { event }
    Keys.onUpPressed: { event }
    Keys.onVolumeDownPressed: { event }
    Keys.onVolumeUpPressed: { event }
    Keys.onYesPressed: { event }
}

// MOUSE EVENT
// Use with MouseArea signals
mouse.accepted // Set to true to stop propagation to parent
mouse.button // button flag that caused the event, can't be Qt.AllButtons
mouse.buttons // mouse buttons pressed when the event was generated
mouse.modifiers // keyboard modifier flags
mouse.source // mouse event source enum
mouse.wasHeld // If the mouse button has been held pressed longer the threshold (800ms)
mouse.x // real, coordinate
mouse.y // real, coordinate

// WHEEL EVENT
// Use with MouseArea signals
wheel.accepted // Set to true to stop propagation to parent
wheel.angleDelta // QML point, degrees rotation in horizontal and vertical, up/right +, down/left -
wheel.buttons // mouse buttons pressed when the event was generated
wheel.inverted // whether the delta values delivered with the event are inverted
wheel.modifiers // keyboard modifier flags
wheel.pixelDelta // QML point, delta in screen pixels, only for high-resolution trackpad support
wheel.x // real, coordinate
wheel.y // real, coordinate

// KEY EVENT
// Use with Key signals
event.accepted // Set to true to stop propagation to parent
event.count // number of keys involved in this event
event.isAutoRepeat // whether this event comes from an auto-repeating key
event.key // holds Qt.Key code
event.modifiers // keyboard modifier flags
event.nativeScanCode // contains the native scan code of the key that was pressed
event.text // Unicode text that the key generated
event.matches(StandardKey.Undo) // Whether key event matches the given standard key

// Mouse Event Source Enum
Qt.MouseEventNotSynthesized            // Actual mouse event from user
Qt.MouseEventSynthesizedBySystemn      // Synthesized from touch or tablet event
Qt.MouseEventSynthesizedByQt           // Synthesized from an unhandled touch or tablet event by Qt
Qt.MouseEventSynthesizedByApplication  // Synthesized by the application
  
// Mouse Button Flags
Qt.RightButton          Qt.MiddleButton
Qt.LeftButton           Qt.AllButtons

// Mouse Cusor Shape Enum
Qt.BlankCursor          Qt.ForbiddenCursor        Qt.SizeAllCursor
Qt.BusyCursor           Qt.OpenHandCursor         Qt.SplitVCursor
Qt.ClosedHandCursor     Qt.PointingHandCursor     Qt.SplitHCursor
Qt.DragCopyCursor       Qt.SizeVerCursor          Qt.WaitCursor
Qt.DragMoveCursor       Qt.SizeHorCursor          Qt.WhatsThisCursor
Qt.DragLinkCursor       Qt.SizeBDiagCursor
Qt.IBeamCursor          Qt.SizeFDiagCursor

// Keyboard Modifier Flags
Qt.NoModifier           Qt.ControlModifier        Qt.MetaModifier
Qt.ShiftModifier        Qt.AltModifier            Qt.KeypadModifier

// Input Focus Reason Enum
Qt.MouseFocusReason         // A mouse action occurred
Qt.TabFocusReason           // The Tab key was pressed
Qt.BacktabFocusReason       // A Backtab occurred, may also include Tab + Shift/Control keys
Qt.ActiveWindowFocusReason  // The window system made this window either active or inactive
Qt.PopupFocusReason         // Application opened/closed a pop-up that grabbed/released the keyboard focus
Qt.ShortcutFocusReason      // The user typed a label's buddy shortcut
Qt.MenuBarFocusReason       // The menu bar took focus
Qt.OtherFocusReason         // Another reason, usually application-specific

//===========================================================================================================
// SHORTCUTS
//===========================================================================================================

// SHORTCUT
// Takes StandardKey.Key or Key String eg. "Ctrl+E,Ctrl+W"
Shortcut {
    autoRepeat: true // default true
    context: Qt.WindowShortcut // default
    sequence: StandardKey.Copy
    sequences: [StandardKey.Cut, StandardKey.Copy]
    onActivated: {}
}

// Shortcut Context Enum
Qt.WindowShortcut       // Active when its parent item is in an active top-level window
Qt.ApplicationShortcut  // Active when one of the application's windows are active

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML DRAG / DROP
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// DRAG
// For specifying drag and drop events for moved Items
// Change in item's position will generate a drag event sent to any DropArea that intersects new position
Item {
    Drag.dragType: Drag.Internal // Default, Drag Type Enum
    Drag.imageSource: "qrc:///icon.png" // Shown during drag event
    Drag.mimeData: { "text/plain": "Copied text" } //  Map of mimeData that is used during startDrag
    Drag.proposedAction: Qt.CopyAction // Recommended return value of Drag.drop(), Drag Action Flags
    Drag.supportedActions: Qt.CopyAction // Return values of Drag.drop() supported, Drag Action Flags
}

// Using Dragged Item as Image Source
Rectangle {
    Drag.active: dragArea.drag.active
    Drag.dragType: Drag.Automatic
    Drag.supportedActions: Qt.CopyAction
    Drag.mimeData: { "text/plain": "Copied text" }
    Text { text: "Some Text" }
    MouseArea {
        id: dragArea
        anchors.fill: parent
        drag.target: parent
        onPressed: parent.grabToImage(function(result) {
            parent.Drag.imageSource = result.url;
        })
    }
}

// DROPAREA
// For specifying drag and drop handling in an area
DropArea {
}

// Drag/Drop Action Flags
Qt.CopyAction      // Copy the data to the target
Qt.MoveAction      // Move the data from the source to the target
Qt.LinkAction      // Create a link from the source to the target.
Qt.IgnoreAction    // Ignore the action (do nothing with the data).

// Drag Type Enum
Drag.None         // Do not start drags automatically
Drag.Automatic    // Start drags automatically
Drag.Internal     // Start backwards compatible drags automatically

// Drag Axis Mask
Drag.XAxis    Drag.YAxis    Drag.XAndYAxis

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML GLOBAL ITEMS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
Qt.application.aboutToQuit.connect(mySlot) // Called on application exit
Qt.application.state // Read only application state enum, undefined without QGuiApplication
Qt.application.layoutDirection // Read only application layout enum, undefined without QGuiApplication
Qt.application.font // Read only default font from QGuiApplication::font, undefined without QGuiApplication
Qt.application.arguments // arguments the executable was invoked with
Qt.application.name // application name set on the QCoreApplication instance
Qt.application.displayName // application display name set on the QCoreApplication instance
Qt.application.version // application version set on the QCoreApplication instance
Qt.application.organization // organization name set on the QCoreApplication instance
Qt.application.domain // organization domain set on the QCoreApplication instance
Qt.application.supportsMultipleWindows // read only whether platform supports multiple windows
Qt.application.screens // array of QML Screen containing the descriptions of all connected screens  
Qt.platform.os // String name of platform
Qt.styleHints // QStyleHints, platform-specific style hints and settings
Qt.atob(data) // decodes the base64 encoded data string and returns it
Qt.btoa(data) // returns a base64 encoding of data
Qt.callLater(myFn, arg1, arg2...) // Call once the QML engine returns to the event loop
Qt.exit(returncode) // causes the QQmlEngine::exit(int) signal to be emitted
Qt.isQtObject(obj) // true if object is a valid reference to a Qt or QML object
Qt.md5(data) // Returns a hex string of the md5 hash of data
Qt.quit() // Quits the application

// APPLICATION STATE
Qt.ApplicationActive     // Top-most and focused, interactable
Qt.ApplicationInactive   // Not top-most or interactable but visible
Qt.ApplicationSuspended  // Not visible or running
Qt.ApplicationHidden     // Not visible but running
  
// APPLICATION LAYOUT
Qt.RightToLeft           // Text and graphics positioned right to left
Qt.LeftToRight           // Text and graphics positioned left to right

// PLATFORM TYPE
"android"   // Android
"ios"       // iOS
"linux"     // Linux
"osx"       // macOS
"unix"      // Other Unix-based OS
"windows"   // Windows

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEBUGGING QML
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
QT CREATOR QML DEBUGGING
1) In the Run Settings, Debugger Settings section, select the Enable QML 
2) Window > Output Panes > Debugger Console allows executing javascript during a break
3) Use the Locals and Expressions views to explore/change the QML item structure
 
PROFILING QML
1) Ensure project built with QML debugging infrastructure
2) Run: app.exe -qmljsdebugger=port:<port>
3) Should output: QML Debugger: Waiting for connection on port <port>
4) Enter console command: qmlprofiler -p <port> -attach <ip address>
**************************************************************************************************************/

QML_IMPORT_TRACE // enable debug output from QML's import loading 
QT_DECLARATIVE_DEBUG / QT_QML_DEBUG // enable the debugging infrastructure

console.log("Message")
console.debug("Message")
console.info("Message")
console.warn("Message")
console.error("Message")
console.assert(exp, "Message on fail")
console.time("timerName") / console.timeEnd("timerName") // log the time (in milliseconds) between the calls
console.trace() // prints stack trace
console.profile() / console.profileEnd() 
console.exception("Message") // prints message and stack trace
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML OPTIMIZATIONS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
PROPERTY OPTIMIZATIONS:
• Avoid declaring with var keyword unless type is QVariantMap/variant
• Using a propery resolves it; faster to store result in local and access that
      var rectColor = rect.color; // resolve the common base.
      printValue("red", rectColor.r);
      printValue("green", rectColor.g)
• Avoid lots of writes to Q_PROPERTIES especially if has notify signal, pefer temp while initialising
      var tempProperty = [];
      tempProperty.length = 100;
      for (var i = 0; i < 100; ++i) {
          tempProperty[i] = i;
      }
      qProperty = tempProperty;
• Avoid binding as container[index] as it will re-evaluate when any container member is changed, do instead
      property int intermediateBinding: cointainer[index]
      property int firstBinding: intermediateBinding + x;
      property int secondBinding: intermediateBinding + y;

PROPERTY BINDING OPTIMZATIONS:
• Avoid declaring intermediate JavaScript variables
• Avoid accessing "var" properties
• Avoid calling JavaScript functions
• Avoid constructing closures or defining functions within the binding expression
• Avoid accessing properties outside of the immediate evaluation scope (non-component properties)
• Avoid writing to other properties
• Prefer binding to anchors over using another component's height/width properties

JAVASCRIPT OPTIMIZATIONS:
• Avoid using eval() if at all possible
• Do not delete properties of objects

COMPONENT OPTIMIZATIONS:
• If a component has a custom property, it becomes its own implicit type. 
  If more than one of these used, move to own file to save memory
• Consider using an asynchronous Loader component
• Prefer Item over invisible Rectangles
• For global data, use singleton types instead of pragma library scripts
  
RENDERING OPTIMIZATIONS:
• Set asynchronous property of images to true for loading
• Set sourceSize property for images to the exact size you want to ensure only what's needed is cached
• Avoid smoothing images using the smooth property
• May be better to disable bindings before and animation and re-enable once finished
• Avoid running JavaScript during animation
• Avoid enabling clipping
• Opaque faster than translucent, only one pixel needed to be considered translucent

MODEL/VIEW OPTIMIZATIONS
• Use WorkerScript with ListModel to move processing to another thread if needed
• Avoid setting the ListModel dynamicRoles property to true
• Avoid using ShaderEffect elements within delegates
• Never enable clipping on a delegate
• Use view cacheBuffer property to allow asynchronous creation and buffering of
  delegates outside of the visible area, at a memory usage increase cost
**************************************************************************************************************/
  
// WORKERSCRIPT
// Run operations in a new thread to prevent blocking of main GUI thread
// Share their own seperate Javascript heap, only allocated if WorkerScript is used
WorkerScript {
    source: "Script.js" // Script file to run in a seperate thread
    onMessage: { console.log(messageObject.result); } // Get reply from the script
}
// Script.js
WorkerScript.onMessage = function(message) {
    // Can send as: boolean, number, string, JavaScript object/array, ListModel objects
    WorkerScript.sendMessage({ "result": 0 });
}
