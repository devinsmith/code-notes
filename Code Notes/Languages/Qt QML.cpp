/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QT MODELING LANGUAGE (QML)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
QML MEMORY ALLOCATION
• Using QML allocates both in C++ heap and javascript garbage collected heap
• WorkerScripts share their own seperate Javascript heap, only allocated if WorkerScript is used
• Adding custom properties makes it an implicit type of the component (allocates memory for new type) 
• Not adding custom properties makes it an explicit type of the component (shares memory for type)

C++ HEAP ALLOCATIONS:
• Overhead of the QML engine (implementation data structures, context information)
• Per-component compiled data and type information, depending which modules/components used
• Per-object C++ data/property values, plus metaobject hierarchy, depending which modules/components used
• Any data which is allocated specifically by QML libraries

JAVASCRIPT HEAP ALLOCATIONS:
• Javascript engine itself including built in types
• Javascript integration: constructor functions for loaded types, function templates
• Variables allocated during expression evaluation
• Per-type layout information and other internal type-data generated by the JavaScript engine at runtime
• Per-object JavaScript data: var properties, functions/signal handlers, non-optimized binding expressions

QML SCENE GRAPH
• Low-level, high-performance rendering stack that renders QML visual items using OpenGL by default
• Allows the scene to be retained between frames and complete set of primitives is known before rendering
• Allows optimizations such as batch rendering to minimize state changes and discarding obscured primitives
• Managed and rendered by the QQuickWindow class 
• Three render loop types: Basic/Windows uses main thread, Threaded uses dedicated thread
• Render loop type auto chosen for hardware, usually Threaded, QSG_RENDER_LOOP forces type
  
SCENE GRAPH NODES
• Added by subclassing QQuickItem::updatePaintNode and setting the QQuickItem::ItemHasContents flag
• Only use classes with the "QSG" prefix inside the QQuickItem::updatePaintNode
• To preprocess, set QSGNode::UsePreprocess and override QSGNode::preprocess; called before rendering
• Each node uses a material (simple OpenGL shader program)

SCENE GRAPH NODE TYPES:
QSGClipNode           Implements the clipping functionality in the scene graph
QSGGeometryNode       Used for all rendered content, describes the shape/mesh of the primitive
QSGNode               The base class for all nodes in the scene graph
QSGOpacityNode        Used to change opacity of nodes
QSGTransformNode      Implements transformations in the scene graph
QSGSimpleRectNode     QSGGeometryNode which defines a rectangular geometry with a solid color material
QSGSimpleTextureNode  QSGGeometryNode which defines a rectangular geometry with a texture material

SCENE GRAPH THREADED RENDER LOOP:
1) QQuickItem::update called when QML scene changed
2) Render thread prepares to draw a new frame
3) Meanwhile GUI thread calls QQuickItem::updatePolish to do final item touch-up
4) GUI thread is blocked
5) QQuickWindow::beforeSynchronizing signal is emitted
6) Synchronization of the QML state into the scene graph by calling QQuickItem::updatePaintNode
7) GUI thread block is released
8) The scene graph is rendered:
     1) QQuickWindow::beforeRendering signal is emitted
     2) QSGNode::preprocess called for those that use it
     3) Renderer processes the nodes and calls OpenGL functions
     4) QQuickWindow::afterRendering signal is emitted
     5) Rendered frame is swapped and QQuickWindow::frameSwapped is emitted
9) Meanwhile GUI is free to advance animations, process events, etc
**************************************************************************************************************/
    
import QtQuick.Controls 2.3
import QtQuick.Controls 1.4 as ControlsLegacy
import MyEnums 1.0    // Requires registering with QQmlEngine
import MyGlobals 1.0  // Requires registering with QQmlEngine
import "MyJavascript.js" as MyJS
  
// ITEM
// Base for most QML components, instantiates QQuickItem
Item {
    id: item                               // unique id of item, can be used to access it
    property int myProperty: 0             // custom property
    property int myProperty: myProperty2   // if myProperty2 changes, re-evaluates myProperty
    property int myProperty: myFunction    // if properties used in function changes, re-evaluates myProperty
    property int myProperty: { return 0; } // if properties used in function changes, re-evaluates myProperty
    property int myProperty: MyJS.fn       // Use function from imported javascript file
    property int myProperty: MyGlobal.fn   // Use function from singleton, Requires registering with QQmlEngine
    property int myProperty: MyEnum.ONE    // Use int type for enums, Requires registering with QQmlEngine
    property var myProperty: myObj         // Context Q_OBJECT, Requires registering with QQuickView
    property int myProperty: myObj.value   // Context Q_OBJECT with Q_PROPERTY 'value' with NOTIFY
    readonly property int myProperty: 0    // read-only property
    property alias myAlias: myProperty     // reference for property    
    signal mySignal(int value)             // call with item.mySignal(0)
      
    /* Attached Property, Called when the item has been instantiated */
    Component.onCompleted: {}

    /* Attached Property, Called when the item is destroyed */
    Component.onDestruction: {}

    /* Called when property has changed, for context Q_OBJECTs emit signal needed */
    onMyPropertyChanged: {}
  
    /* Called when signal emitted, 'value' arg passed in */
    onMySignal: { value }
  
    /* Called when signal emitted, requires calling signal.connect */
    function mySlot(value) {}
    
    /* Use a specific namespace control */
    ControlsLegacy.Rectangle {}

    /* Javascript custom function */
    function myFunction(x, y) {
        return x + y;
    }
  
    /* Item states, if multiple 'when' true, first is chosen */
    states: [
        State {
            name: "state1" 
            PropertyChanges { target: item; myProperty: 1 } 
            when: myBoolProperty
        },
        State { 
            name: "state2" 
            PropertyChanges { target: item; myProperty: 2 }
            when: myFunction
        }
    ]  
}
item.mySignal.connect(mySlot) // Connect signal and slot
item.activeFocus // Read only, whether item has active focus
item.activeFocusOnTab // Whether included in active focus on tab, default false
item.antialiasing // Whether antialiasing enable, default false
item.baselineOffset // Position offset, default 0, used for text
item.childrenRect // Read only, QML rect collective position and size of the item's children
item.clip // Whether clipping enabled, default false, hides part of item/children, performance hit
item.enabled // Recursive, whether the item receives mouse and keyboard events
item.focus // Whether item has input focus
item.height // Actual height of item
item.width // Actual width of item
item.implicitHeight // Default height of the Item if no height is specified
item.implicitWidth // Default width of the Item if no width is specified
item.opacity // Alpha of item, values outside [0,1] clamped
item.objectName // Inherited from QObject
item.parent // returns Item, visual parent of the item
item.rotation // rotation of the item in degrees clockwise around its transformOrigin, default 0
item.scale // size of item, negative mirror's item, default 1
item.smooth // Image interpolation, true is linear, false is nearest neighbour, default true
item.transformOrigin // TransformOrigin type which scale/rotate use
item.visible // Recursive, whether item is rendered
item.x / item.y / item.z // Position and stacking depth of item, negative z draws under parent
item.anchors // Sub options: top, bottom, left, right, horizontalCenter, verticalCenter, baseLine
item.anchors.fill // Takes QML Item parent or sibling, set to undefined to detach
item.anchors.centerIn // Takes QML Item parent or sibling, set to undefined to detach
item.anchors.margins // Set value for all margins
item.anchors.topMargin // Set value for top margin
item.anchors.bottomMargin // Set value for bottom margin
item.anchors.leftMargin // Set value for left margin
item.anchors.rightMargin // Set value for right margin
item.anchors.horizontalCenterOffset // Value offset from horizontal center
item.anchors.verticalCenterOffset // Value offset from vertical center
item.anchors.baselineOffset // Value offset from position
item.anchors.alignWhenCentered // forces centered anchors to align to a whole pixel, default true
item.data // list<Object> of both visual children and resources
item.layer.effect // Component, typically a ShaderEffect component
item.layer.enabled // Whether the item is layered or not, disabled by default
item.layer.format // Enum, internal OpenGL format of the texture
item.layer.mipmap // Whether mipmaps are generated for the texture
item.layer.samplerName // Name of the effect's source texture property
item.layer.samples // Enum, allows requesting multisampled rendering in the layer
item.layer.smooth // Whether the layer is smoothly transformed
item.layer.sourceRect // The rectangular area of the item that should be rendered into the texture
item.layer.textureMirroring // Enum, how the generated OpenGL texture should be mirrored
item.layer.textureSize // Pixel size of the layers texture, if empty (default) uses item's size
item.layer.wrapMode // Enum, OpenGL wrap modes associated with the texture
item.resources // list<Object>, contains non-visual children
item.state // QString state name, default empty
item.states // list<State>, list of possible states for this item
item.transform // list<Transform>, list of transformations to apply
item.transitions // list<Transition>, transitions to be applied to the item whenever it changes its state
item.visibleChildren // list<Item>, contains visual children
item.childAt(x, y) // Returns first visible QML Item child found at point within item coord system
item.contains(point) // If item contains QML point (in local coordinates)
item.forceActiveFocus(reason) // Focuses item and any parent FocusScopes, reason optional
item.grabToImage(callback, targetSize) // Grabs the item into an in-memory image
item.grabToImage(function(result) { result.saveToFile("/Folder/image.png"); }) // Save as image
item.mapFromGlobal(x, y) // Converts global coords into item local coords, retuns QML point
item.mapFromItem(item2, x, y, w, h) // Converts item2 local coords into item local coords, retuns QML rect
item.mapFromItem(item2, x, y) // Converts item2 local coords into item local coords, retuns QML point
item.mapToGlobal(x, y) // Converts item local coords into global coords, returns QML point
item.mapToItem(item2, x, y, w, h) // Converts item local coords into item2 local coords, returns QML rect
item.mapToItem(item2, x, y) // Converts item local coords into item2 local coords, returns QML point
item.nextItemInFocusChain(forward) // Returns item next in the focus chain, forward optional

// MyGlobal.qml
// Requires registering with QQmlEngine
pragma Singleton
import QtQuick 2.4
QtObject {
    property value: 0
    function fn() {
        return 0;
    }
}

// MyJavascript.js
// Make a library to enable sharing across all QML files
var value = 0;
function fn() {
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML BASIC TYPES
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
property bool myBool: true
property double myDouble: 0.0
property int myInt: 0
property real myReal: 0.0

// VAR
// Use for holding Javascript types, QVariantMap and variant
// Object attributes do not send signal or update bindings when changed
property var myFn: (function() { return 0; }) // Javascript function
property var myArray: [1, 2, 3, "a", "b"] // Javascript array
property var myObj: { "a":0, "b":1 } // Javascript object
property var myObj: ({ a:0, b:1 }) // Javascript object, requires () without "
property var myObj: new Object({ "a":0, "b":1 }) // Javascript object
property int myAttr: myObj.a // Will not update when 'a' updates

// LIST
// list of QML objects, not a Javascript array
// Auto converts to/from QmlListProperty
property list myList
myList.length // item count in list
myList[index] // access item
  
// POINT
// Auto converts to/from QPoint and QPoint
// Attributes do not have signals, use onMyPointChanged instead
property point myPoint: Qt.point(0, 20)
property point myPoint: "0,20"
myPoint.x / myPoint.y
  
// RECT
// Auto converts to/from QRect and QRectF
// Attributes do not have signals, use onMyRectChanged instead
property rect myRect: "50,50,100x100"
property rect myRect: Qt.rect(50, 50, 100, 100)
myRect.x / myRect.y
myRect.width
myRect.height
myRect.top // read-only
myRect.bottom // read-only
myRect.left // read-only
myRect.right // read-only

// SIZE
// Auto converts to/from QSize and QSizeF
// Attributes do not have signals, use onMySizeChanged instead
property size mySize: "150x50"
property size mySize: Qt.size(150, 50)
mySize.width
mySize.height

// URL
// Auto converts to/from QUrl
property url myUrl: "folder/image.png" // Relative path, will be converted to absolute
property url myUrl: "file:///folder/image.png" // Absolute path
property url myUrl: "qrc:///folder/image.png" // Resource path
myUrl == Qt.resolvedUrl("folder/image.png") // Comparison
myUrl.toString() // Returns the absolute path
Qt.resolvedUrl(myUrl) // Returns url resolved relative to the URL of the caller

// STRING
// Auto converts to/from QString
// Attributes do not have signals, use onMyStrChanged instead
property string myStr: "str"
myStr.length
Qt.qsTrId(id) // returns translated string at id, else id if no translation
Qt.qsTrIdNoOp(id) // Marks id for dynamic translation, returns id

//===========================================================================================================
// QML DATE
//===========================================================================================================

// DATE
// Auto converts to/from QDate and QDateTime
property date myDate: "2020-12-31"
  
// Takes JavaScript Date or QML date, returns date as string
// Format defaults Qt.SystemLocaleShortDate, can be Date Format Enum or Date Format String
Qt.formatDate(date, format)
Qt.formatDateTime(date, format)
Qt.formatTime(date, format)
  
// Date Format Enum
Qt.TextDate                // ddd MMM d yyyy
Qt.ISODate                 // yyyy-MM-dd or yyyy-MM-ddTHH:mm:ss or with a time-zone suffix 
Qt.ISODateWithMs           // Qt.ISODate with ms
Qt.SystemLocaleShortDate   // The short format used by the operating system
Qt.SystemLocaleLongDate    // The long format used by the operating system
Qt.DefaultLocaleShortDate  // The short format specified by the application's locale
Qt.DefaultLocaleLongDate   // The long format specified by the application's locale
  
// Date Format String
// Can use space . and : to seperate (eg. "ddd MMMM d yy" )
d     // the day as number without a leading zero (1 to 31)
dd    // the day as number with a leading zero (01 to 31)
ddd   // the abbreviated localized day name (e.g. 'Mon' to 'Sun'). Uses QDate::shortDayName()
dddd  // the long localized day name (e.g. 'Monday' to 'Qt::Sunday'). Uses QDate::longDayName()
M     // the month as number without a leading zero (1-12)
MM    // the month as number with a leading zero (01-12)
MMM   // the abbreviated localized month name (e.g. 'Jan' to 'Dec'). Uses QDate::shortMonthName()
MMMM  // the long localized month name (e.g. 'January' to 'December'). Uses QDate::longMonthName()
yy    // the year as two digit number (00-99)
yyyy  // the year as four digit number
h     // the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
hh    // the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
m     // the minute without a leading zero (0 to 59)
mm    // the minute with a leading zero (00 to 59)
s     // the second without a leading zero (0 to 59)
ss    // the second with a leading zero (00 to 59)
z     // the milliseconds without leading zeroes (0 to 999)
zzz   // the milliseconds with leading zeroes (000 to 999)
AP    // use AM/PM display. AP will be replaced by either "AM" or "PM"
ap    // use am/pm display. ap will be replaced by either "am" or "pm"
t     // include a time-zone indicator

//===========================================================================================================
// QML COLOR
//===========================================================================================================

// COLOR
// ARGB color value, auto converts to/from QColor
// Attributes do not have signals, use onMyColorChanged instead
property color myColor: "red"
property color myColor: "#RRGGBB"
property color myColor: "#AARRGGBB"
property color myColor: Qt.rgba(r, g, b, a) // All real in range [0.0,1.0]
Qt.hsva(hue, saturation, value, alpha) // All real in range [0.0,1.0]
Qt.hsla(hue, saturation, lightness, alpha) // All real in range [0.0,1.0]
Qt.darker(myColor, v) // Returns darker color by converting to HSV then value/v, v <= 0 unspecified
Qt.darker(myColor) // Returns color 50% darker than myColor
Qt.lighter(myColor, v) // Returns lighter color by converting to HSV then value*v, v <= 0 unspecified
Qt.lighter(myColor) // Returns color 50% lighter than myColor
Qt.tint(myColor, tintColor) // Returns color with tintColor overlaying myColor
Qt.colorEqual(myColor, myColor2) // Either argument can be Color or string type
myColor.r / myColor.g / myColor.b / myColor.a
myColor.hsvHue
myColor.hsvSaturation
myColor.hsvValue 
myColor.hslHue
myColor.hslSaturation
myColor.hslLightness

// PALETTE
// Each property is QML color
property palette myPalette
myPalette.alternateBase // Alternate background color in item views with alternating row colors
myPalette.base // Background color for text editor controls and items views
myPalette.brightText // Text color that contrasts well with palette.dark, used on  highlighted buttons
myPalette.button // General button background color
myPalette.buttonText // Foreground color used with the palette.button color
myPalette.dark // Darker than palette.button
myPalette.highlight // Color to indicate a selected item or the current item
myPalette.highlightedText // Text color that contrasts with palette.highlight
myPalette.light // Lighter than palette.button
myPalette.link // Text color used for hyperlinks
myPalette.linkVisited // Text color used for already visited hyperlinks
myPalette.mid // Between palette.button and palette.dark
myPalette.midlight // Between palette.button and palette.light
myPalette.shadow // A very dark color
myPalette.text // Foreground color used with palette.base
myPalette.toolTipBase // Used as the background color for tooltips
myPalette.toolTipText // Used as the foreground color for tooltips
myPalette.window // General background color
myPalette.windowText // General foreground color

//===========================================================================================================
// QML MATH
//===========================================================================================================

// MATRIX4X4
// Attributes do not have signals, use onMyMatChanged instead
property matrix4x4 myMat: Qt.matrix4x4(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
myMat.m11...myMat.m44
myMat.column(index) // returns vector4d, zero-based index
myMat.determinant() // returns real
myMat.fuzzyEquals(myMat2, epsilon) // epsilon is real
myMat.inverted() // returns myMat inverted
myMat.minus(myMat2) // myMat - myMat2
myMat.plus(myMat2) // myMat + myMat2
myMat.row(index) // returns vector4d, zero-based index
myMat.times(myMat2) // multiplying myMat with myMat4
myMat.times(myVec) // transforming vector3d or vector4d with the 4x4 matrix
myMat.times(value) // multiply matrix by real scalar
myMat.toString()
myMat.transposed() // returns myMat transposed

// QUATERNION
// Attributes do not have signals, use onMyQuatChanged instead
property quaternion myQuat: "1.0,0,1,0" // scalar,x,y,z
property quaternion myQuat: Qt.quaternion(1.0,0,1,0) // scalar,x,y,z
myQuat.x / myQuat.y / myQuat.z
myQuat.scalar

// VECTOR2D
// Attributes do not have signals, use onMyVecChanged instead
property vector2d myVec: "0,1"
property vector2d myVec: Qt.vector2d(0,1)
myVec.x / myVec.y
myVec.dotProduct(myVec2) // returns real
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector3d() // returns vector3d, z component is set to 0
myVec.toVector4d() // returns vector4d, z/w components set to 0
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

// VECTOR3D
// Attributes do not have signals, use onMyVecChanged instead
property vector3d myVec: "0,1,0"
property vector3d myVec: Qt.vector3d(0,1,0)
myVec.x / myVec.y / myVec.z
myVec.crossProduct(myVec2) // returns vector x vector2
myVec.dotProduct(myVec2) // returns real
myVec.times(matrix) // transforming vector with the 4x4 matrix
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector2d() // returns vector2d, z component dropped
myVec.toVector4d() // returns vector4d, w component set to 0
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

// VECTOR4D
// Attributes do not have signals, use onMyVecChanged instead
property vector4d myVec: "0,1,0,1"
property vector4d myVec: Qt.vector3d(0,1,0,1)
myVec.x / myVec.y / myVec.z / myVec.w
myVec.dotProduct(myVec2) // returns real
myVec.times(matrix) // transforming vector with the 4x4 matrix
myVec.times(myVec2) // returns vector * vector2
myVec.times(value) // returns vector * value
myVec.plus(myVec2) // returns vector + vector2
myVec.minus(myVec2) // returns vector - vector2
myVec.normalized() // returns vector normalized
myVec.length() // returns real
myVec.toVector2d() // returns vector2d, z/w components dropped
myVec.toVector3d() // returns vector3d, w component dropped
myVec.fuzzyEquals(myVec2, epsilon) // epsilon is real
myVec.toString()

//===========================================================================================================
// QML FONT
//===========================================================================================================

// FONT
// Auto converts to/from QFont
// If no matching font exists, Qt will use the closest matching installed font
// Attributes do not have signals, use onMyFontChanged instead
property font myFont: Qt.font({ family: "Helvetica", weight: Font.Black })
Qt.fontFamilies() // Returns list<string> of font families available
myFont.family // String font family name
myFont.bold // Whether bold
myFont.italic // Whether italic
myFont.underline // Whether has underline
myFont.pointSize // real, device independent
myFont.pixelSize // Overrides pointSize, int, device dependent
myFont.weight // Font Weighting Enum
myFont.overline // Whether has overline
myFont.strikeout // Whether line through it
myFont.capitalization // Font Capitalization Enum
myFont.letterSpacing // real, spacing between characters
myFont.wordSpacing // real, spacing between words
myFont.kerning // Whether to auto adjust character spacing, default enabled
myFont.preferShaping // Whether to enable display/spacing rules, default enabled
myFont.hintingPreference // Font Hinting Enum

// Font Weighting Enum
Font.Thin          Font.Normal       Font.Bold       
Font.ExtraLight    Font.Medium       Font.ExtraBold  
Font.Light         Font.DemiBold     Font.Black
  
// Font Capitalization Enum
Font.MixedCase       // No change
Font.AllUppercase    // Render in all uppercase
Font.AllLowercase    // Render in all lowercase
Font.SmallCaps       // Render in all small-caps
Font.Capitalize      // Render with the first character of each word as uppercase
  
// Font Hinting Enum
// Adjusts an outline (non-rastor) font so it lines up with a rasterized grid
// Important for displaying small text, only used with "NativeRendering"
Font.PreferDefaultHinting    // default hinting level
Font.PreferNoHinting         // render text without hinting
Font.PreferVerticalHinting   // no horizontal hinting, but align in the vertical direction
Font.PreferFullHinting       // hinting in both horizontal and vertical directions

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML LAYOUTS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// LAYOUT ATTACHED PROPERTIES
// Use these on any components inside the layout
Layout.alignment // Layout Alignment Flags
Layout.bottomMargin // Overrides margin property if set
Layout.column // column position of an item in a GridLayout
Layout.columnSpan // column span of an item in a GridLayout
Layout.fillHeight // Uses preferredHeight if false
Layout.fillWidth // Uses preferredWidth if false
Layout.leftMargin // Overrides margin property if set
Layout.margins // Spacing between items
Layout.maximumHeight // Number.POSITIVE_INFINITY default
Layout.maximumWidth // Number.POSITIVE_INFINITY default
Layout.minimumHeight // 0 default
Layout.minimumWidth // 0 default
Layout.preferredHeight // if -1 (default), will be ignored, and item's implicitHeight used instead
Layout.preferredWidth // if -1 (default), will be ignored, and item's implicitWidth used instead
Layout.rightMargin // Overrides margin property if set
Layout.row // row position of an item in a GridLayout
Layout.rowSpan // row span of an item in a GridLayout
Layout.topMargin // Overrides margin property if set

// Layout Alignment Flags
Qt.AlignLeft       Qt.AlignTop
Qt.AlignHCenter    Qt.AlignVCenter
Qt.AlignRight      Qt.AlignBottom
Qt.AlignBaseline

// ROWLAYOUT
// Inherits Item, Aligns elements after each other in a single row
RowLayout {
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

// COLUMNLAYOUT
// Inherits Item, Aligns elements after each other in a single column
ColumnLayout {
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

// GRIDLAYOUT
// Inherits Item, Aligns elements in a grid with n columns
GridLayout {
    columns: 3
    spacing: 5
    anchors.fill: parent // Still use anchors on base
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML DYNAMIC CREATION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
// CREATE COMPONENT
// Returns a Component object created using qml url, parent can be null
// Use createObject to create an object instance of this component, will return null if failed
// incubator can be used to load instances asynchronously
var component = Qt.createComponent("MyQML.qml");
console.log(component.errorString());
if (component.status == Component.Ready) {
    var obj = component.createObject(parent, {"x": 100, "y": 100});
    var obj = component.createObject(parent, {"x": Qt.binding(function() { return item.x; })});
  
    var incubator = component.incubateObject(parent, { x: 10, y: 10 });
    if (incubator.status != Component.Ready) {
        incubator.onStatusChanged = function(status) {
            if (status == Component.Ready) {
                var obj = incubator.object;
            }
        }
    }
}

// Component State Enum
Component.Null     // no data is available for the component
Component.Ready    // the component has been loaded, and can be used to create instances
Component.Loading  // the component is currently being loaded
Component.Error    // an error occurred while loading the component

// CREATE QML OBJECT
// Will be null if error creating object
// Any imports used here must also be at top of file
var obj = Qt.createQmlObject('import QtQuick 2.0; Rectangle {width: 20; height: 20}', parent);

// LOADER
// Dynamic loading from a URL or Component
// If an explicit size is not set for Loader, automatically resized to the size of the loaded item
// Signals emitted from the loaded object can be received using the Connections type
// Use myLoader.item to access dynamic-created item
// If using external myComponent, it can only see properties in myLoader, not in any of myLoader parents
Loader {
    id: loader
    sourceComponent: component // set to undefined or change to destroy items
    sourceComponent: Component { } // Supports inline
    source: "MyItem.qml" // set to "" or change to destroy items
    focus: true // must be set to true for any of its children to get the active focus
    onLoaded: {} // Signal when loading complete
}
loader.active // Set to false destroys, doesn't auto create if source/sourceComponent changes, true creates
loader.asynchronous // Default false, change to false while loading will force it to finish synchronously
loader.item // Item loaded, not available until Loader.Ready state
loader.progress // Progress real [0.0, 1.0]
loader.status // Status enum value

// Loader State Enum
Loader.Null     // the loader is inactive or no QML source has been set
Loader.Ready    // the QML source has been loaded
Loader.Loading  // the QML source is currently being loaded
Loader.Error    // an error occurred while loading the QML source

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QT MODELS / VIEWS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*************************************************************************************************************
• Model: Contains the data and its structure
• View: A container that displays the data. The view might display the data in a list or a grid.
• Delegate: Determines how each element of data should appear in the view. Can also access each element.
• Role: Used to access different attributes of a data element in the model
**************************************************************************************************************/

ScrollView {
    Layout.fillWidth: true
    Layout.fillHeight: true 
    ListView {
        id: listView
        Layout.fillWidth: true
        Layout.fillHeight: true
        model: context_model // Set through C++

        onCurrentIndexChanged: {
            console.log("Selected " + currentIndex);
        }          
        onCurrentItemChanged: {
            console.log("Selected " + currentItem);
        }
        
        // Each item of the model is instantiated with the delegate
        delegate: Item {
            id: del
            property bool isHighlighted: mouseArea.containsMouse
            property bool isSelected: listView.currentIndex == index
            property bool isSelected: ListView.isCurrentItem // Alternative
              
            MouseArea {
                id: mouseArea
                anchors.fill: parent
                hoverEnabled: true
                acceptedButtons: Qt.RightButton | Qt.LeftButton
                onPressed: { listView.currentIndex = index; }
                onClicked: { listView.currentIndex = index; }
            }                   
            Text {
                width: listView.width
                height: 30
                text: role_name // Set through C++
            }
        }
    }
}

//===========================================================================================================
// QML VIEWS
//===========================================================================================================

// LISTVIEW / GRIDVIEW / PATHVIEW SHARED PROPERTIES
{
    currentIndex: 0 // Index of currently selected item, -1 is no selection
    delegate: Component {} // Template defining each item instantiated by the view
    highlight: Component {} // Only creates one which follows selected item
    highlightItem: Item {} // Only creates one which follows selected item 
    highlightMoveDuration: -1 // Default -1, take as many seconds as needed
    highlightRangeMode: <T>.NoHighlightRange // Default, View Highlight Range Enum
    preferredHighlightBegin: 1.0 // Preferred range of the highlight, affected by highlightRangeMode
    preferredHighlightEnd: 2.0 // Preferred range of the highlight, affected by highlightRangeMode
    snapMode: <T>.NoSnap // default, View Snap Mode Enum
    model: myModel // Contains data to display            
}
view.currentItem // Currently selected Item, null is no selection
view.count // Number of items in the view
view.indexAt(x, y) // Returns index of item containing the point x, y in content coords, or -1
view.itemAt(x, y) // Returns item containing the point x, y in content coords, or null
view.positionViewAtIndex(index, mode) // Positions at index by View Position View Mode Enum

// LISTVIEW / GRIDVIEW SHARED PROPERTIES
{
    cacheBuffer: 20 // Explicitly set the buffer size for caching delegates outside the view 
    footer: Component {} // Component to use as the footer
    footerItem: Item {} // Item to use as the footer
    header: Component {} // Component to use as the header
    headerItem: Item {} // Item to use as the header
    highlightFollowsCurrentItem: true // Whether highlight positioning is managed by view
    keyNavigationEnabled: true // Whether the key navigation enabled, bound to Flickable.interactive
    keyNavigationWraps: true // Key navigation that puts selection out of bounds will wrap
    layoutDirection: Qt.LeftToRight // default, View Layout Direction Enum
    verticalLayoutDirection: <T>.TopToBottom // default, View Vertical Layout Direction Enum   
    add: Transition {} // On add of an item
    addDisplaced: Transition {} // On move of items when displaced from an item add
    displaced: Transition {} // On generic displace of items, overridden by add/moveDisplaced
    move: Transition {} // On move of an item
    moveDisplaced: Transition {} // On move of items when displaced from an item move
    populate: Transition {} // On initial populate of items
    remove: Transition {} // On remove of an item
    removeDisplaced: Transition {} // On move of items when displaced from an item remove 
}
view.forceLayout() // Forces an update of the view, otherwise updates batched to happen once per frame
view.positionViewAtBeginning() // Positions the view at the beginning
view.positionViewAtEnd() // Positions the view at the end
  
// LISTVIEW
// Inherits Flickable, Display items from a model in a list
// Delegates are instantiated as needed and may be destroyed at any time
ListView {
    currentSection: "section" // Section that is currently at the beginning of the view
    footerPositioning: ListView.InlineFooter // ListView Footer Positioning Enum
    headerPositioning: ListView.InlineHeader // ListView Header Positioning Enum
    highlightMoveVelocity: 400 // Default 400 pixels/second
    highlightResizeDuration: -1 // Default -1, take as many seconds as needed
    highlightResizeVelocity: 400 // Default 400 pixels/second
    orientation: ListView.Vertical // ListView Orientation Enum
    section.property: "section" // Name of section
    section.criteria: ViewSection.FullString // default, View Section Criteria Enum
    section.delegate: Component {} // Instantiated for each section header
    section.labelPositioning: ViewSection.InlineLabels // default, View Section Positioning
    spacing: 0 // default, Spacing between items
}
view.decrementCurrentIndex() // Decrements the current index, will wrap depending on keyNavigationWraps
view.incrementCurrentIndex() // Increments the current index, will wrap depending on keyNavigationWraps
  
// GRIDVIEW
// Inherits Flickable, Display items from a model in a grid
GridView {
    cellHeight: 100 // default, height of each cell in the grid
    cellWidth: 100 // default, width of each cell in the grid
    flow: GridView.FlowLeftToRight // default, GridView Flow Enum
}
view.moveCurrentIndexDown() // Moves selected down one, will wrap if keyNavigationWraps is true
view.moveCurrentIndexLeft() // Moves selected left one, will wrap if keyNavigationWraps is true
view.moveCurrentIndexRight() // Moves selected right one, will wrap if keyNavigationWraps is true
view.moveCurrentIndexUp() // Moves selected up one, will wrap if keyNavigationWraps is true

// PATHVIEW
// Inherits Item, Lays out model-provided items on a path
PathView {
    cacheItemCount
    dragMargin
    dragging
    flickDeceleration
    flicking
    interactive
    maximumFlickVelocity
    movementDirection
    moving
    offset
    path
    pathItemCount
    onDragEnded: {}
    onDragStarted: {}
    onFlickEnded: {}
    onFlickStarted: {}
    onMovementEnded: {}
    onMovementStarted: {}
}
view.decrementCurrentIndex() // Decrements the current index
view.incrementCurrentIndex() // Increments the current index

// View Layout Direction Enum
Qt.LeftToRight   // Items will be laid out from left to right
Qt.RightToLeft   // Items will be laid out from right to left
  
// View Section Positioning
ViewSection.InlineLabels         // Section labels scroll inline
ViewSection.CurrentLabelAtStart  // Section labels stick to top when scrolling
ViewSection.NextLabelAtEnd       // Section labels stick to end when scrolling
  
// View Section Criteria Enum
ViewSection.FullString      // Sections created based on the section.property value
ViewSection.FirstCharacter  // Sections created based on the first char of the section.property value

// ListView / GridView / PathView Snap Mode Enum
// How the view scrolling will settle following a drag or flick
<T>.NoSnap         // Stops anywhere within the visible area
<T>.SnapToItem     // Settles with an item aligned with the start of the view
<T>.SnapOneItem    // Settles no more than one item away from first visible item on mouse release

// ListView / GridView / PathView Highlight Range Enum
<T>.ApplyRange            // Can move outside of range at the end of list or due to mouse interaction
<T>.StrictlyEnforceRange  // Never move outside range, changes selected item if outside range
<T>.NoHighlightRange      // No range used

// ListView / GridView / PathView Position View Mode Enum
<T>.Beginning      // Position at start
<T>.Center         // Position at center
<T>.End            // Position at end
<T>.Visible        // Ensure a part of the item is visible
<T>.Contain        // Ensure the entire item is visible
<T>.SnapPosition   // Position at preferredHighlightBegin, only for StrictlyEnforceRange or !NoSnap

// ListView / GridView Vertical Layout Direction Enum
<T>.TopToBottom    // Items laid out top to bottom
<T>.BottomToTop    // Items laid out bottom to top

// ListView Header/Footer Positioning Enum
ListView.InlineFooter      // Positioned at the end, connected/will move as a normal item
ListView.OverlayFooter     // Positioned at the end, won't move
ListView.PullBackFooter    // Positioned at the end, can be pushed/pulled
ListView.InlineHeader      // Positioned at the start, connected/will move as a normal item
ListView.OverlayHeader     // Positioned at the start, won't move
ListView.PullBackHeader    // Positioned at the start, can be pushed/pulled

// ListView Orientation Enum
ListView.Horizontal        // Items are laid out horizontally
ListView.Vertical          // Items are laid out vertically

// GridView Flow Enum
GridView.FlowLeftToRight   // Items are laid out from left to right, and the view scrolls vertically
GridView.FlowTopToBottom   // Items are laid out from top to bottom, and the view scrolls horizontally

//===========================================================================================================
// QML DELEGATES
//===========================================================================================================

// DELEGATE DEFAULT ROLES
display       // Qt::DisplayRole, QString
decoration    // Qt::DecorationRole, QColor, QIcon or QPixmap
edit          // Qt::EditRole, QString    
toolTip       // Qt::ToolTipRole, QString  
statusTip     // Qt::StatusTipRole, QString
whatsThis     // Qt::WhatsThisRole, QString

// DELEGATE PROPERTIES
// Given to any delegate Item, don't have to use ItemDelegate type
Item {
    <T>.onAdd: {} // Emitted immediately after an item is added to the view for List/GridView
    <T>.onRemove: {} // Emitted immediately before an item is removed from the view for List/GridView
} 
del.model // Role data for each delegate item, eg. model.role_name
del.modelData // If view's model has no roles, use to access item data for delegate
del.index // Index in view, can be -1 if removed from view
del.<T>.view // Use to access List/Grid/PathView if delegate created outside it
del.<T>.isCurrentItem // Whether the delegate is the currently selected item of List/Grid/PathView
del.<T>.delayRemove // Whether delegate has to delay destruction (eg. to finish animation) of List/GridView
del.ListView.nextSection // Section string of the next item
del.ListView.previousSection  // Section string of the previous item
del.ListView.section // Section string of the item
del.PathView.onPath // Whether the item is currently on the path

// ITEMDELEGATE
// Inherits AbstractButton, Basic item delegate
ItemDelegate {
    highlighted: ListView.isCurrentItem // set whether the delegate is highlighted
}

// CHECKDELEGATE
// Inherits ItemDelegate, has check indicator that can be toggled on or off
CheckDelegate {
}

// RADIODELEGATE
// Inherits ItemDelegate, has radio indicator that can be toggled on or off
RadioDelegate {
}

// SWITCHDELEGATE
// Inherits ItemDelegate, has a switch indicator that can be toggled on or off
SwitchDelegate {
}

// SWIPEDELEGATE
// Inherits ItemDelegate, Swipable item delegate
SwipeDelegate {
}

//===========================================================================================================
// QML MODELS
//===========================================================================================================

// DERIVED QABSTRACTITEMMODELS
// Parent is const QModelIndex&, get using model.index
model.match(index, role, value) // Returns QModelIndexList of first item in index's column with role with value
model.match(index, role, value, hits) // Number of items to look for, use -1 to return all matches
model.match(index, role, value, hits, flags) // MatchFlags with default Qt.MatchStartsWith | Qt.MatchWrap
model.headerData(section, orientation, role) // Default role display, Orientation Enum, returns QVariant
model.setData(index, value, role) // Default role edit, true if successful
model.data(index, role) // Default role display, returns QVariant
model.hasChildren(parent) // parent optional, whether parent has child items
model.columnCount(parent) // parent optional, amount of columns
model.rowCount(parent) // parent optional, amount of rows
model.sibling(row, column, index) // Returns QModelIndex, row/column relative to index
model.hasChildren(parent) // parent optional, whether parent has child items
model.index(row, column, parent) // parent optional, returns QModelIndex
model.hasIndex(row, column, parent) // parent optional, whether index is valid
model.parent(index) // Returns QModelIndex

// LISTMODEL
// free-form list data source
ListModel {
}

// XMLLISTMODEL
// read-only model using XPath expressions
XmlListModel {
}

// OBJECTMODEL
// Defines a set of items to be used as a model
ObjectModel {
}

// ITEMSELECTIONMODEL
// Instantiates QItemSelectionModel, Allows keeping the selection state of multiple views in sync
// QML views do not use QModelIndex, need to convert to it when using ItemSelectionModel
ItemSelectionModel {
}
var modelIndex = model.index(view.currentIndex, 0) // Get QModelIndex from view
ism.select(modelIndex, ItemSelectionModel.Select | ItemSelectionModel.Current)
  
// QAbstractItemModel Orientation Enum
Qt.Horizontal   
Qt.Vertical

// QAbstractItemModel MatchFlags
Qt.MatchExactly          // Performs QVariant-based matching
Qt.MatchFixedString      // Performs string-based matching, case-insensitive unless MatchCaseSensitive flag
Qt.MatchContains         // The search term is contained in the item
Qt.MatchStartsWith       // The search term matches the start of the item
Qt.MatchEndsWith         // The search term matches the end of the item
Qt.MatchCaseSensitive    // The search is case sensitive
Qt.MatchRegExp           // Performs string-based matching using a regular expression as the search term
Qt.MatchWildcard         // Performs string-based matching using a string with wildcards as the search term
Qt.MatchWrap             // Perform a search that wraps around so all items are searched
Qt.MatchRecursive        // Searches the entire hierarchy including children

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML INPUT HANDLING
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
Qt.Key            http://doc.qt.io/qt-5/qt.html#Key-enum
StandardKey.Key   http://doc.qt.io/qt-5/qkeysequence.html#StandardKey-enum

TAB STOP: The location the cursor stops after the tab key is pressed
ACTIVE FOCUS: Item or FocusScope child currently receiving keyboard input

COMPOSED MOUSE EVENT:
• Clicked, doubleClicked and pressAndHold, composed of basic mouse events like pressed
• Changing the accepted property of the mouse parameter has no effect unless propagateComposedEvents true

KEY HANDLING STEPS:
1) Qt receives the key action and generates a key event
2) If a QQuickWindow is the active window, the key event is delivered to it
3) The key event is delivered to the Item with active focus. If none with focus then event ignored
4) If the Item accepts the key event, propagation stops
5) If the Item declines, the event is sent to the Item's parent until the event is accepted or root reached
**************************************************************************************************************/

// FOCUSSCOPE
FocusScope {
}

// MOUSEAREA
// Inherits Item
MouseArea {
    acceptedButtons: Qt.LeftButton // default
    cursorShape: Qt.ArrowCursor // default
    drag.target: item // Item to drag
    drag.axis: Drag.XAxis // Axis mask
    drag.minimumX: 1.0 // how far the target can be dragged along the axis
    drag.maximumX: 1.0 // how far the target can be dragged along the axis
    drag.minimumY: 1.0 // how far the target can be dragged along the axis
    drag.maximumY: 1.0 // how far the target can be dragged along the axis
    drag.filterChildren: true // drag can override descendant MouseAreas, so parent can handle drag
    drag.threshold: 1 // determines the threshold in pixels of when the drag operation should start
    drag.smoothed: true // target will be moved only after the drag operation has started, default true
    enabled: true // overrides Item.enabled, only skips mouse events
    hoverEnabled: true // whether hover events are handled
    pressAndHoldInterval: // overrides the elapsed time in milliseconds before pressAndHold is emitted
    preventStealing: true // prevents mouse events being stolen from area by parent, default false
    propagateComposedEvents: true // sends composed events to overlapping areas in lower visual stack order
    scrollGestureEnabled: true // whether responds to scroll gestures from non-mouse device, default true
    onCanceled: {} // When another item stole the mouse event handling
    onClicked: { mouse } // Composed event, Press and release both inside area
    onDoubleClicked: { mouse } // Composed event, Press followed by a release followed by a press
    onEntered: {} // Only on press unless hoved enabled, then on enter of area
    onExit: {} // Only on press unless hoved enabled, then on exit of area
    onPositionChanged: { mouse } // Only on press unless hoved enabled, then on mouse move in area
    onPressed: { mouse } // On press
    onPressAndHold: { mouse } // Composed event, press longer than 800 ms
    onReleased: { mouse } // On release 
    onWheel: { wheel } // Mouse wheel and trackpad scroll gestures
}
area.containsMouse // whether the mouse is currently inside the mouse area
area.containsPress // pressed && containsMouse
area.drag.active // if the target item is currently being dragged
area.mouseX // local to area, valid only on press, or if hover enabled, if cursor inside area
area.mouseY // local to area, valid only on press, or if hover enabled, if cursor inside area
area.pressed // whether any of the acceptedButtons are currently pressed
area.pressedButtons // mouse buttons currently pressed, can't be Qt.AllButtons

// KEYS
// Add to any Item, each signal has key event
Item {
    Keys.enabled: true // enable signals for this item, default true
    Keys.forwardTo: [item1, item2] // forwards event to each item, once accepted stops forwarding
    Keys.onAsteriskPressed: { event }
    Keys.onBackPressed: { event }
    Keys.onBacktabPressed: { event }
    Keys.onCallPressed: { event }
    Keys.onCancelPressed: { event }
    Keys.onContext1Pressed: { event } // Supports Context1 to Context4
    Keys.onDeletePressed: { event }
    Keys.onDigit0Pressed: { event } // Supports Digit0 to Digit9
    Keys.onDownPressed: { event }
    Keys.onEnterPressed: { event }
    Keys.onEscapePressed: { event }
    Keys.onFlipPressed: { event }
    Keys.onHangupPressed: { event }
    Keys.onLeftPressed: { event }
    Keys.onMenuPressed: { event }
    Keys.onNoPressed: { event }
    Keys.onPressed: { event }
    Keys.onReleased: { event }
    Keys.onReturnPressed: { event }
    Keys.onRightPressed: { event }
    Keys.onSelectPressed: { event }
    Keys.onShortcutOverride: { event }
    Keys.onSpacePressed: { event }
    Keys.onTabPressed: { event }
    Keys.onUpPressed: { event }
    Keys.onVolumeDownPressed: { event }
    Keys.onVolumeUpPressed: { event }
    Keys.onYesPressed: { event }
}

// MOUSE EVENT
// Use with MouseArea signals
mouse.accepted // Set to true to stop propagation to parent
mouse.button // button flag that caused the event, can't be Qt.AllButtons
mouse.buttons // mouse buttons pressed when the event was generated
mouse.modifiers // keyboard modifier flags
mouse.source // mouse event source enum
mouse.wasHeld // If the mouse button has been held pressed longer the threshold (800ms)
mouse.x // real, coordinate
mouse.y // real, coordinate

// WHEEL EVENT
// Use with MouseArea signals
wheel.accepted // Set to true to stop propagation to parent
wheel.angleDelta // QML point, degrees rotation in horizontal and vertical, up/right +, down/left -
wheel.buttons // mouse buttons pressed when the event was generated
wheel.inverted // whether the delta values delivered with the event are inverted
wheel.modifiers // keyboard modifier flags
wheel.pixelDelta // QML point, delta in screen pixels, only for high-resolution trackpad support
wheel.x // real, coordinate
wheel.y // real, coordinate

// KEY EVENT
// Use with Key signals
event.accepted // Set to true to stop propagation to parent
event.count // number of keys involved in this event
event.isAutoRepeat // whether this event comes from an auto-repeating key
event.key // holds Qt.Key code
event.modifiers // keyboard modifier flags
event.nativeScanCode // contains the native scan code of the key that was pressed
event.text // Unicode text that the key generated
event.matches(StandardKey.Undo) // Whether key event matches the given standard key

// Mouse Event Source Enum
Qt.MouseEventNotSynthesized            // Actual mouse event from user
Qt.MouseEventSynthesizedBySystemn      // Synthesized from touch or tablet event
Qt.MouseEventSynthesizedByQt           // Synthesized from an unhandled touch or tablet event by Qt
Qt.MouseEventSynthesizedByApplication  // Synthesized by the application
  
// Mouse Button Flags
Qt.RightButton          Qt.MiddleButton
Qt.LeftButton           Qt.AllButtons

// Mouse Cusor Shape Enum
Qt.BlankCursor          Qt.ForbiddenCursor        Qt.SizeAllCursor
Qt.BusyCursor           Qt.OpenHandCursor         Qt.SplitVCursor
Qt.ClosedHandCursor     Qt.PointingHandCursor     Qt.SplitHCursor
Qt.DragCopyCursor       Qt.SizeVerCursor          Qt.WaitCursor
Qt.DragMoveCursor       Qt.SizeHorCursor          Qt.WhatsThisCursor
Qt.DragLinkCursor       Qt.SizeBDiagCursor
Qt.IBeamCursor          Qt.SizeFDiagCursor

// Keyboard Modifier Flags
Qt.NoModifier           Qt.ControlModifier        Qt.MetaModifier
Qt.ShiftModifier        Qt.AltModifier            Qt.KeypadModifier

// Input Focus Reason Enum
Qt.MouseFocusReason         // A mouse action occurred
Qt.TabFocusReason           // The Tab key was pressed
Qt.BacktabFocusReason       // A Backtab occurred, may also include Tab + Shift/Control keys
Qt.ActiveWindowFocusReason  // The window system made this window either active or inactive
Qt.PopupFocusReason         // Application opened/closed a pop-up that grabbed/released the keyboard focus
Qt.ShortcutFocusReason      // The user typed a label's buddy shortcut
Qt.MenuBarFocusReason       // The menu bar took focus
Qt.OtherFocusReason         // Another reason, usually application-specific

//===========================================================================================================
// SHORTCUTS
//===========================================================================================================

// SHORTCUT
// Takes StandardKey.Key or Key String eg. "Ctrl+E,Ctrl+W"
Shortcut {
    autoRepeat: true // default true
    context: Qt.WindowShortcut // default
    sequence: StandardKey.Copy
    sequences: [StandardKey.Cut, StandardKey.Copy]
    onActivated: {}
}

// Shortcut Context Enum
Qt.WindowShortcut       // Active when its parent item is in an active top-level window
Qt.ApplicationShortcut  // Active when one of the application's windows are active

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML DRAG / DROP
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// DRAG
// For specifying drag and drop events for moved Items
// Change in item's position will generate a drag event sent to any DropArea that intersects new position
Item {
    Drag.dragType: Drag.Internal // Default, Drag Type Enum
    Drag.imageSource: "qrc:///icon.png" // Shown during drag event
    Drag.mimeData: { "text/plain": "Copied text" } //  Map of mimeData that is used during startDrag
    Drag.proposedAction: Qt.CopyAction // Recommended return value of Drag.drop(), Drag Action Flags
    Drag.supportedActions: Qt.CopyAction // Return values of Drag.drop() supported, Drag Action Flags
}

// Using Dragged Item as Image Source
Rectangle {
    Drag.active: dragArea.drag.active
    Drag.dragType: Drag.Automatic
    Drag.supportedActions: Qt.CopyAction
    Drag.mimeData: { "text/plain": "Copied text" }
    Text { text: "Some Text" }
    MouseArea {
        id: dragArea
        anchors.fill: parent
        drag.target: parent
        onPressed: parent.grabToImage(function(result) {
            parent.Drag.imageSource = result.url;
        })
    }
}

// DROPAREA
// For specifying drag and drop handling in an area
DropArea {
}

// Drag/Drop Action Flags
Qt.CopyAction      // Copy the data to the target
Qt.MoveAction      // Move the data from the source to the target
Qt.LinkAction      // Create a link from the source to the target.
Qt.IgnoreAction    // Ignore the action (do nothing with the data).

// Drag Type Enum
Drag.None         // Do not start drags automatically
Drag.Automatic    // Start drags automatically
Drag.Internal     // Start backwards compatible drags automatically

// Drag Axis Mask
Drag.XAxis    Drag.YAxis    Drag.XAndYAxis

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML GLOBAL ITEMS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
Qt.application.aboutToQuit.connect(mySlot) // Called on application exit
Qt.application.state // Read only application state enum, undefined without QGuiApplication
Qt.application.layoutDirection // Read only application layout enum, undefined without QGuiApplication
Qt.application.font // Read only default font from QGuiApplication::font, undefined without QGuiApplication
Qt.application.arguments // arguments the executable was invoked with
Qt.application.name // application name set on the QCoreApplication instance
Qt.application.displayName // application display name set on the QCoreApplication instance
Qt.application.version // application version set on the QCoreApplication instance
Qt.application.organization // organization name set on the QCoreApplication instance
Qt.application.domain // organization domain set on the QCoreApplication instance
Qt.application.supportsMultipleWindows // read only whether platform supports multiple windows
Qt.application.screens // array of QML Screen containing the descriptions of all connected screens  
Qt.platform.os // String name of platform
Qt.styleHints // QStyleHints, platform-specific style hints and settings
Qt.atob(data) // decodes the base64 encoded data string and returns it
Qt.btoa(data) // returns a base64 encoding of data
Qt.callLater(myFn, arg1, arg2...) // Call once the QML engine returns to the event loop
Qt.exit(returncode) // causes the QQmlEngine::exit(int) signal to be emitted
Qt.isQtObject(obj) // true if object is a valid reference to a Qt or QML object
Qt.md5(data) // Returns a hex string of the md5 hash of data
Qt.quit() // Quits the application

// APPLICATION STATE
Qt.ApplicationActive     // Top-most and focused, interactable
Qt.ApplicationInactive   // Not top-most or interactable but visible
Qt.ApplicationSuspended  // Not visible or running
Qt.ApplicationHidden     // Not visible but running
  
// APPLICATION LAYOUT
Qt.RightToLeft           // Text and graphics positioned right to left
Qt.LeftToRight           // Text and graphics positioned left to right

// PLATFORM TYPE
"android"   // Android
"ios"       // iOS
"linux"     // Linux
"osx"       // macOS
"unix"      // Other Unix-based OS
"windows"   // Windows

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEBUGGING QML
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
QT CREATOR QML DEBUGGING
1) In the Run Settings, Debugger Settings section, select the Enable QML 
2) Window > Output Panes > Debugger Console allows executing javascript during a break
3) Use the Locals and Expressions views to explore/change the QML item structure
 
PROFILING QML
1) Ensure project built with QML debugging infrastructure
2) Run: app.exe -qmljsdebugger=port:<port>
3) Should output: QML Debugger: Waiting for connection on port <port>
4) Enter console command: qmlprofiler -p <port> -attach <ip address>
**************************************************************************************************************/

QML_IMPORT_TRACE // enable debug output from QML's import loading 
QT_DECLARATIVE_DEBUG / QT_QML_DEBUG // enable the debugging infrastructure

console.log("Message")
console.debug("Message")
console.info("Message")
console.warn("Message")
console.error("Message")
console.assert(exp, "Message on fail")
console.time("timerName") / console.timeEnd("timerName") // log the time (in milliseconds) between the calls
console.trace() // prints stack trace
console.profile() / console.profileEnd() 
console.exception("Message") // prints message and stack trace
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QML OPTIMIZATIONS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************************************************
PROPERTY OPTIMIZATIONS:
• Avoid declaring with var keyword unless type is QVariantMap/variant
• Using a propery resolves it; faster to store result in local and access that
      var rectColor = rect.color; // resolve the common base.
      printValue("red", rectColor.r);
      printValue("green", rectColor.g)
• Avoid lots of writes to Q_PROPERTIES especially if has notify signal, pefer temp while initialising
      var tempProperty = [];
      tempProperty.length = 100;
      for (var i = 0; i < 100; ++i) {
          tempProperty[i] = i;
      }
      qProperty = tempProperty;
• Avoid binding as container[index] as it will re-evaluate when any container member is changed, do instead
      property int intermediateBinding: cointainer[index]
      property int firstBinding: intermediateBinding + x;
      property int secondBinding: intermediateBinding + y;

PROPERTY BINDING OPTIMZATIONS:
• Avoid declaring intermediate JavaScript variables
• Avoid accessing "var" properties
• Avoid calling JavaScript functions
• Avoid constructing closures or defining functions within the binding expression
• Avoid accessing properties outside of the immediate evaluation scope (non-component properties)
• Avoid writing to other properties
• Prefer binding to anchors over using another component's height/width properties

JAVASCRIPT OPTIMIZATIONS:
• Avoid using eval() if at all possible
• Do not delete properties of objects

COMPONENT OPTIMIZATIONS:
• If a component has a custom property, it becomes its own implicit type. 
  If more than one of these used, move to own file to save memory
• Consider using an asynchronous Loader component
• Prefer Item over invisible Rectangles
• For global data, use singleton types instead of pragma library scripts
  
RENDERING OPTIMIZATIONS:
• Set asynchronous property of images to true for loading
• Set sourceSize property for images to the exact size you want to ensure only what's needed is cached
• Avoid smoothing images using the smooth property
• May be better to disable bindings before and animation and re-enable once finished
• Avoid running JavaScript during animation
• Avoid enabling clipping
• Opaque faster than translucent, only one pixel needed to be considered translucent

MODEL/VIEW OPTIMIZATIONS
• Use WorkerScript with ListModel to move processing to another thread if needed
• Avoid setting the ListModel dynamicRoles property to true
• Avoid using ShaderEffect elements within delegates
• Never enable clipping on a delegate
• Use view cacheBuffer property to allow asynchronous creation and buffering of
  delegates outside of the visible area, at a memory usage increase cost
**************************************************************************************************************/
  
// WORKERSCRIPT
// Run operations in a new thread to prevent blocking of main GUI thread
// Share their own seperate Javascript heap, only allocated if WorkerScript is used
WorkerScript {
    source: "Script.js" // Script file to run in a seperate thread
    onMessage: { console.log(messageObject.result); } // Get reply from the script
}
// Script.js
WorkerScript.onMessage = function(message) {
    // Can send as: boolean, number, string, JavaScript object/array, ListModel objects
    WorkerScript.sendMessage({ "result": 0 });
}
