//////////////////////////////////////////////////////////////////////////////////////////////
//C++ NOTES
//////////////////////////////////////////////////////////////////////////////////////////////

unsigned char         BYTE        ---
short                 ---         short int / signed short / signed short int
unsigned short        WORD        unsigned short int
int                   INT/BOOL    signed 
unsigned int          UINT        unsigned
long                  ---         long int / signed long / signed long int
unsigned long         ULONG       unsigned long int
long long             ---         long long int / signed long long / signed long long int
unsigned long long    DWORD       unsigned long long int
float                 FLOAT       ---

STATIC VARIABLES
• Variables with static storage duration:
    - Global variables: Doesn't require 'static' keyword
    - Class member variables: Require 'static' keyword
    - Local variables: Require 'static' keyword
• All static variables zero-initialisated or initialised to constant before main() called
• If dynamic initialisation is required, can be initialised any time between main() 
  and first use of variable (or object if class member)

GLOBAL VARIABLES
• Defined outside function or class scope
• Have static storage duration
• Automatically has 'static' keyword unless 'extern' keyword is used, can't have both
• If same named non-extern static and extern variable exist then error
          -------------------------------------------
          | static int x      |                     |
          | int x             | extern int x        |
-----------------------------------------------------
|         | creates copy for  | References extern   |
| .H      | every #include    | version in .cpp     |
|         |                   |                     |
| .CPP    | creates only one  | Definition for any  |
|         | for .cpp use      | .h extern versions  |
|         |                   |                     |
| Linkage | Internal          | External            |
|         | Single use        | Shared use          |
-----------------------------------------------------

TEMPORARY VARIABLES
• Move semantics reduces creation of temp variables
• Value-typed variables auto created on the stack during:
   - reference initialization
   - expression evaluation
   - automatic type conversion
   - function passing/returning if no move constructor

CONST VARIABLES
• String constants and floating point constants are stored in static memory in optimized code
• Integer constants are usually included as part of the instruction code
• If type unknown or is refered to, may be stored in fixed seperate memory/data segment
• Variable const-casted remains in same location but cannot change values
• Cannot use move operations on const variables

ZERO-INITIALISATION
• All Static variables before main()
• POD types after default constructor is called
    - MyPOD obj = {};
    - MyPOD[2] array = {};
    - MyPOD* obj = new MyPOD{};
    - MyPOD obj = MyPOD(); 
    - MyPOD* obj = new MyPOD();
• POD type members that are not user initialised in {}
    - MyPOD obj = { 5 };
    - MyPOD[2] array = { 5 }; 
    - MyPOD* obj = new MyPOD{ 5 };

SEQUENCE POINTS
• Undefined behaviour when changing a variable and reading it again without a sequence point.
• After a function's returned object has been copied back to the caller
• After evaluation of all a function's parameters when the function is called
• After the initialization of each base and member for an object
;       int x = 0;
,       f(x,y) 
||      x || y 
&&      x && y 
?:      x ? y : 0 

//////////////////////////////////////////////////////////////////////////////////////////////
//MOVE SEMANTICS
//////////////////////////////////////////////////////////////////////////////////////////////

• Allows resources to transfer between objects rather than copying
• Automatically done if object has a valid move assignment/constructor
• All function parameters are lvalue even if initialised with an rvalue
• Don't use with const objects: move becomes copy operation

UNIVERSAL REFERENCES
• T&& (not const T&&) that uses Reference Collapsing to bind to both rvalue/lvalue references
• Requires type deduction that must be determined each time its called (not class templates)
• Requires Pefect Fowarding to pass on arguments
• Bad for overloading: instantiate to create exact matches for almost any type of argument

PERFECT FORWARDING
• Function templates that take arbitrary arguments and forward exactly the same arguments
• Preserves R/L value-ness of passed args as all function params are lvalues
• std::foward used to pass on correct type by casting to rvalue if pass argument was an rvalue
• Fails with {}, NULL, static const members without a definition, template/overloaded function names, bitfields

REFERENCE COLLAPSING
• Occurs in universal references, typedef T&& MyTypedef, aliases and decltype
• When lvalue reference is passed to T&&, creates type MyClass& && which collapses to MyClass&
• Only compiler can create type T& && for collapsing, otherwise error

//////////////////////////////////////////////////////////////////////////////////////////////
//MEMORY ALLOCATION
//////////////////////////////////////////////////////////////////////////////////////////////

VARIABLES/OBJECTS: &name gives address of object
C-STYLE ARRAY: name gives address of first element
CSTRING/STRING LITERAL: name gives string, &name gives address of first character

POINTERS/REFERENCES DIFFERENCES
• Pointers hold a memory address; reference is another name for variable.
• Pointer must be dereferenced, reference just uses name
• References can't change once initialised. Pointers can change what they point to.s
• References can't easily be nullptr or void, pointers can
• Pointers use -> for classes/structures while references use .

NEW AND DELETE
• Don’t use delete to free memory that new didn’t allocate.
• Don’t use delete to free the same block of memory twice in succession.
• Use delete [] if you used new [] to allocate an array.
• Use delete (no brackets) if you used new to allocate a single entity.
• It’s safe to apply delete to the null pointer (nothing happens).

MEMSET
• memset used to zero out memory or wipe sensitive data
• Can be optimised out by compilier if deemed not affecting program
• Dangerous to use on non-POD types due to wiping hidden members (vptr etc)
• memset_s never optimised

RESOURCE ACQUISITION IS INITIALIZATION (RAII)
• Aquiring and owning a resource means cleaning that resource up properly
• If an exception is thrown or return happens, 'delete' may never be called
• Resource cleaning needs to be tied to the lifespace of objects for automatic allocation/deletion
• Vital for exception and thread safe code

//////////////////////////////////////////////////////////////////////////////////////////////
//SMART POINTERS
//////////////////////////////////////////////////////////////////////////////////////////////

UNIQUE/SCOPED POINTER
• Has sole ownership of memory allocated, can only be moved
• By default are same size as raw pointers and call 'delete' on destruction
• Deleter is part of unique_ptr type and can change its size
• Has version for pointer and version for array
• Can be converted to shared_ptr
• If type is forward declared, implicit methods (ie. destructor) inlined 
  in .h may use static_assert which require the full type. Declare these 
  functions =default in the .cpp file (MyClass::~MyClass() = default;)

SHARED POINTER
• Reference counted shared ownership of memory allocated, can be copied/moved
• Hold two raw pointers: one to memory, one to control block
• Control block dynamically allocated only once on first pointer creation
• Control block holds holds reference count, weak count, deleter, memory allocator
• Control block uses virtual inheritance
• Modifying reference count is thread-safe atomic operation (slower)
• Deleter is not part of type and does not require full type for implicit methods
• Has only version for pointer (doesn't support arrays)
• Can't detect cyclic dependencies
• Can't be converted to unique_ptr
• new allocates memory twice while make_shared allocates memory for control block and object together
• When reference count is 0, memory/control block deleted unless weak count > 0 then 
  holds onto control block (and object memory if allocated together)

WEAK POINTER
• Non-owning observers of an object owned by shared_ptr
• Hold two raw pointers: one to memory, one to control block
• Creates shared_ptr when using
• Only contribute to weak count which may prevent releasing of object memory
• When object is deleted, all pointers are marked as invalid
• Useful when having cyclic dependencies and in place of raw pointers

INTRUSIVE POINTER
• Shared pointer where reference counting is not done by the pointer object
• Helper function is used which is defined by the object that is pointed to

AUTO POINTER
• Has sole ownership of the object which is passed if the pointer is copied
• If copied the original is set to nullptr; passing by-ref is okay
• Can't point to arrays due to it using delete, not delete []
• Can't point to memory on the stack
• Can't be used in STL containers due to it's transfer ownership property

ARRAY POINTERS
• boost scoped_array; Simple sole ownership of arrays. Noncopyable.
• boost shared_array; Array ownership shared among multiple pointers.

SMART POINTER DESTRUCTION
• Calls delete by default (unless deleter given) on loss of scope/reference count 0
• If local in a noexcept function which throws may not be destroyed
• If std::abort, std::exit, std::quick_exit is called will not be destroyed

////////////////////////////////////////////////////////////////////////////////////////////////////
//CLASSES/STRUCTS/FUNCTIONS
////////////////////////////////////////////////////////////////////////////////////////////////////

ORDER OF ARGUMENT EVALUATION
Order that function parameters are evaluated is up to the complier.
callFunc(getA(),getB()); can either be:

  int a = getA();       int b = getB();
  int b = getB();  OR   int a = getA();
  callFunc(a,b);        callFunc(a,b);

STRUCTURE/CLASS DIFFERENCES
• Class members/inheritance is private by default
• Struct members/inheritance is public by default

RULE OF THREE
• If you define a destructor, copy constructor or assignment 
  operator, it's likely you need to define the other two

COPY-SWAP IDIOM
• Allows assignment operator not duplicating copy constructor, useful for deep copying
• Used for exception safty in assignment operator when allocating new memory
• Requires non-throwing swap function, copy constructor and destructor
• Passes argument in by-val; if construction fails, 'this' never used in body
  which gives strong exception guarantee

BITWISE CONST CHECKING
• Occurs if function doesn't modify any class non-static members 
• Doesn't include what a member pointer points to or returned values
• Compilers check for this in functions to determine if function meets constness

RETURN VALUE OPTIMIZATION (RVO)
• If possible, a returned local var is constructed in memory allocated for function's return value
• If not possible, a returned local var is treated as rvalue (automatically uses std::move)
• Using std::move/std::foward explicitly will prevent RVO for ever occuring
• Only use std::move/std::foward on return if returning by-value a T&& (or else copy will occur)

INLINING FUNCTIONS
• Function call is replaced by function body
• Compiler ultimately decides what is inlined
• If in .h any internal static members are shared between files
• May increase program size unless a very small inlined function
• Large inlined functions used alot can increase execution time due to caching
• Increases build time as all uses need to be recompiled rather than just relinked

=====================================================================================
CLASS LIFETIME
=====================================================================================
• References must be initialised through the initialisation list
• Don't call virtual methods in constructor/destructor; undefined behaviour; calls Base version
• Initialisation list doesn't reflect order of construction
• Static member variables initialised before program begins

1) Base class(es) Initialisation List called
2) Base class(es) Constructor Body called
3) Derived Initialisation List called
4) Derived Constructor Body called
5) Derived Destructor called
6) Base Desctructor called

ORDER OF BASE CLASS CONSTRUCTION
1) Virtual base classes, depth first, left to right ordering
2) Normal base classes in order of declaration

=====================================================================================
DEFAULT IMPLICIT MEMBER FUNCTIONS
=====================================================================================
• Are generated inline in class header
• To generate in .cpp, delcare in header and use =default on definition
• =default generates implicit version and is not considered user-defined
• Templates never suppres generation of implicit member functions

IMPLICIT FUNCTIONS:
• Destructor
• Address operator
• Constructor
• Copy constructor
• Copy Assignment operater
• Move constructor
• Move assignment operator

ALL METHOD REQUIREMENTS:
• Create if function is required for usage of the class
• Create if no user version of function exists (=default okay)
• Create if function doesn't have =delete

COPY METHOD REQUIREMENTS:
• Does memberwise shallow copy of non-static data members
• Create if all members can be copy-assigned/copied automatically
• Create if no move-assignment or move constructor defined
• Will create if one needed and matching copy method is user-defined

MOVE METHOD REQUIREMENTS:
• Does memberwise moving of non-static data members
• Create if all members can be move-assigned/moved automatically
• Create if no destructor, copy-assignment, copy constructor defined
• Will NOT create if one needed and matching move method is user-defined

//////////////////////////////////////////////////////////////////////////////////////////////
//INHERITANCE
//////////////////////////////////////////////////////////////////////////////////////////////

--------------------------------------------------------
FUNCTION      INHERITED    IMPLICIT  VIRTUAL  RETURNS
--------------------------------------------------------
Constructors  No           Yes        No      No
Destructor    No           Yes        Yes     No
Operator=     No           Yes        Yes     Yes
Operator&     Yes          Yes        Yes     Yes
Operator[]    Yes          No         Yes     Yes
Conversion    Yes          No         Yes     Yes
Friends       No           No         Yes     -
            
PUBLIC INHERITANCE
• Allows derived cast to base
• Base protected/public members can be accessed by derived class
• Base public members can be accessed by everything

PROTECTED INHERITANCE
• Doesn't allow derived cast to base
• Base public members cannot be accessed outside derived class
• Base protected/public members can be accessed by derived class
• Base protected/public members can be accessed by further derived classes 

PRIVATE INHERITANCE
• Doesn't allow derived cast to base
• Base public members cannot be accessed outside derived class
• Base protected/public members can be accessed by derived class
• Base protected/public members cannot be accessed by further derived classes

VIRTUAL FUNCTIONS:
• Function that can be redefined in a derived class to provide a different implementation
• Pointers/references will call virtual functions based on underlying object type stored
• Pointers/references will call non-virtual functions based on the type of pointer
• Virtual destructor required if using base pointer holding derived type else base destructor not called
• Protected non-virtual destructor prevents deleting base pointer holding derived type 
• Slower than normal functions as additional requirement to access vtbl/compiler cannot optimize (eg. inline)
• Can't be a template function as once the run-time system figured out it would need to call a templatized 
  virtual function, compilation is all done and the compiler cannot generate the appropriate instance anymore

VIRTUAL FUNCTION REQUIREMENTS:
• Virtual keyword on base class function
• Matching function signatures including constness on all overriding functions
• Matchine refence qualifiers on all overriding functions
• Compatible return type and exception specifications

NON-VIRTUAL INTERFACE IDIOM:
• Virtual function visibility in derived/base don't have to match
• Chosen visibility determined from type of pointer/reference used
• If virtual base function shouldn't be called, make it private

V-TABLE VIRTUAL FUNCTION TABLE:
• Vtbl is array of function addresses for a class that has virtual functions in the static data segment
• Usually stored as a static array at compile-time though exact implementation compiler specific
• One hidden vptr per class hierarchy is created
• When virtual function called, vtble used to find the correct address
• Stores the classes's type_info object used for RTTI

RUN-TIME TYPE INDENTIFICATION (RTTI)
• Allows determining type of derived class from a base class *
• Only works on classes that use virtual methods as type_info stored in vtbl
• Sometimes turned off- must enable run time type info setting

PURE VIRTUAL CLASS/ABSTRACT BASE CLASS
• Base class where a method is declared but not defined; pure virtual method

VIRTUAL BASE CLASS
• Creates a shared base class if more than two of the same base class exist
• Number of times virtual inheritance is used in hierarchy is number of hidden pointers created
• Constructor of virtual base classes called by most derived class first

-----------------------------------------------------------------------------
                         +Object size    +Class size    Prevents inlining
-----------------------------------------------------------------------------
Virtual Functions            Yes             Yes             Yes 
Multiple Inheritance         Yes             Yes             No 
Virtual Base Classes         Yes             Yes             No 
RTTI                         No              Yes             No 

//////////////////////////////////////////////////////////////////////////////////////////////
//FUNCTION OVERLOADING
//////////////////////////////////////////////////////////////////////////////////////////////

REQUIRES SIGNATURE DIFFERENCE
• Type of parameters
• Number of parameters
• Const or non-const reference/pointers

OVERLOAD RESOLUTION ORDER
• Template functions never implicitly cast
• Prefer exact non-template type over template
• Implicit casting always last priority, never explicitly casts
• Uses SFINAE: substitution failure is not an error where the compilier 
  can reject template types without throwing any errors

FN(1.0F, 1.0F)
1) Non-template Exact type                        void Fn(float x, float y)
2) Template Explicit Specialization Exact type    template <> void Fn(float x, float y) [requires 3]
3) Template Overloads with Exact type             template <typename T> void Fn(T x, float y)
   OR Template Overload                           template <typename T> void Fn(T x, T y)
5) Primary Template                               template <typename T, typename S> void Fn(T x, S y)
6) Non-template with Implicit conversion          void Fn(float x, double y)

FN<FLOAT>(1.0F, 1.0F)
1) Template Explicit Specialization Exact type    template <> void Fn(float x, float y) [requires 2]
2) Template Overloads with Exact type             template <typename T> void Fn(T x, float y)
   OR Template Overload                           template <typename T> void Fn(T x, T y)
3) Primary Template                               template <typename T, typename S> void Fn(T x, S y)

OPERATOR OVERLOADING RESTRICTIONS
• Must have one argument as an object
• Can't change precedence
• Can't create new symbols

CAN'T BE OVERLOADED
.         The membership operator
.*        The pointer-to-member operator
::        The scope-resolution operator
?:        The conditional operator
sizeof    The sizeof operator

ONLY OVERLOADED BY CLASS
=         Assignment operator
()        Function call operator
[]        Subscripting operator
->        Class member access by pointer operator

CAN BE OVERLOADED
+       -       *       /       %       ^
&       |       ~=      !       =       <
>       +=      -=      *=      /=      %=
^=      &=      |=      <<      >>      >>=
<<=     ==      !=      <=      >=      &&
||      ++      --      ,       ->*     ->
()      []      new     delete  new[]   delete[]

//////////////////////////////////////////////////////////////////////////////////////////////
//EXCEPTIONS
//////////////////////////////////////////////////////////////////////////////////////////////

NOEXCEPT FUNCTIONS
• If objects they work on throw, undefined behaviour
• All destructors automatically have noexcept keyword
• std::swap has noexcept keyword

EXCEPTIONS IN CONSTRUCTORS
• On exception construction has failed and the object never existed
• On exception the destructor does not need to be called
• On exception the try-catch block cannot suppress; implicitly rethrows if trying to suppress
• On exception any members requiring explicit cleanup in destructor will be leaked
• Cannot access any class members in catch block as out of scope

EXCEPTIONS IN DESTRUCTORS
• Destructors should never throw: if unwinding the stack from an 
  exception and a destructor throws the program is terminated

STANDARD LIBRARY EXCEPTIONS
• Exception neutral
• Mostly has strong exception guarantee with a few basic guarantees
• Multi-range insert(begin,begin,end) has basic guarantee
• Vector and Deque only: inserts or erases for multi or single objects are basic guarantee 
  if object constructor or assignment operator throws, otherwise strong guarantee

//////////////////////////////////////////////////////////////////////////////////////////////
//STL ALGORITHMS
//////////////////////////////////////////////////////////////////////////////////////////////

ATAN-ATAN2 DIFFERENCES:
ATAN2: Looks at 4 quadrants
ATAN: Looks at 2 quadrants
                                   +y
    atan(-x/+y) = +angle [0,-90]   |   atan(+x/+y) = +angle [0,90]
   atan2(-x,+y) = +angle [0,-90]   |   atan2(+x,+y) = +angle [0,90]
                                   |
                       -x----------|----------+x
                                   |
    atan(-x/-y) = +angle [0,-90]   |   atan(+x/-y) = -angle [0,90)
atan2(-x,-y) = +angle [-90,-180)   |   atan2(+x,-y) = +angle [90,180]
                                   -y

• Non-modifying: on const objects; Modifying: on non-const objects
• Preferable to use container's equivalent method for stability
• All ranges are [Start, End) with End non-inclusive
• Comparison lambdas should always return false for equal values
• Functors used are passed by-val and copied
• In-built functors are faster than passing lambdas/function pointers due to them being inlined

CONDITION          UNSORTED      SORTED               SET/MAP         MULTI SET/MAP
does obj exist     std::find     std::binary_search  .count()        .find()
find obj           std::find     std::equal_range    .count()        .find()     
no. obj with val   std::count    std::equal_range    .count()        .count()
find all obj       std::find     std::equal_range    .equal_range()  .equal_range()
find obj if        std::find_if  std::lower_bound    .lower_bound()  .lower_bound()      

SORT/SEARCHING
• Sorting Fastest-slowest: Partitions, partial_sort, sort, stable_sort
• Require sort ascending, Search speed O(logN): binary_search, lower_bound, upper_bound, equal_range
• Don't require sorting, Search speed O(N): count, count_if, find, find_if
• std::sort must be any algorithm with O(NlogN), std::stable_sort must be stable with O(NlogN)
                    
INSERTING
• Algorithms that copy over a range can be changed to insert with back/front insert iterators
• Emplacing is always as (if not more) effecient as insert/push
• Never emplace arguments allocating memory through new in case of memory exception; use push/insert

//////////////////////////////////////////////////////////////////////////////////////////////
//STL CONTAINERS
//////////////////////////////////////////////////////////////////////////////////////////////

======================================================================================
SEQUENCE CONTAINERS
======================================================================================

VECTOR
• random access to elements
• keeps values in one chunk of continuous memory

DEQUE
• double ended queue with random access
• stores data in various chucks with pointers to keep track of next lot
• not safe with pointer maths as memory not all in one piece

LIST/FORWARD LIST
• List: doubly-linked list with iteration in both directions
• Forward List: single-linked lists with iteration only forward
• Forward list smaller and more effecient
• not safe with pointer maths as memory not all in one piece
• no random access, must iterate through list
• search slow due to waiting for spread out data to be fetched into the cache
• Handles large, complex elements well

STRING
• Stored on the stack (Short String Optimization) if capacity <= 15 characters else on the heap
• Moving strings with SSO has no performance gain over copying them
• If on the stack and string grows can be moved to the heap
• Data for strings not guaranteed to be stored in continuous memory
• Internal representation of string not guaranteed to end with null character

VECTOR<BOOL>
• Not a STL container and doesn't hold bools
• Each element occupies single bit and represents bitfields
• Can't create pointers/references to individual bits so uses proxy
• vector<bool>::iterator is not random-access, forward or bi-directional
• deque<bool> actually contains bool; vector<bool> was an experiment
• Saves space but slower as requires going through proxy object
• Don't use auto when accessing members as type chosen is std::vector<bool>::reference

--------------------------------------------------------------------------
SINGLE DATA:
--------------------------------------------------------------------------
Push Front:      deque/list O(1)     < vector O(n)
Push Back:       vector O(1)         < deque O(1)      < list
Random Insert:   vector/deque        < list
Random Remove:   vector/deque        < list
std::sort:       vector              < deque           < list
std::find:       vector              < deque           < list
Iterating:       vector/deque        < list
Destruction:     vector/deque        < list
Random Access:   vector              < deque
--------------------------------------------------------------------------                
COMPLEX DATA:   
--------------------------------------------------------------------------
Push Front:      deque/list O(1)     < vector
Push Back:       vector/deque O(1)   < list
Random Insert:   list O(1)           < deque             < vector
Random Remove:   list O(1)           < deque  O(n/2)     < vector
std::sort:       list                < vector/deque
std::find:       deque               < vector            < list
Iterating:       vector/deque        < list
Destruction:     vector              < deque/list
Random Access:   vector              < deque

======================================================================================
CONTAINER ADAPTERS
======================================================================================

QUEUE
• first-in-first-out
• no iteration/random access
• built on top of deque using inline functions

PRIORITY-QUEUE
• first-in-first-out
• no iteration/random access
• sorted in terms of most important using heap search
• built on top of vector & heap structure using inline functions 

STACK
• last-in-first-out
• no iteration/random access
• built on top of deque using inline functions

HEAP
• created using a vector/deque container
• Element with highest value is always at top of heap
• Fast insertion of new elements

======================================================================================
ASSOCIATIVE CONTAINERS
======================================================================================

• Default sort function is operator< and is auto sorted when new key is inserted
• Keys are const and should not be changed as this affects the sort order

MAP
• Based on balanced binary tree
• Sorted from lowest to highest with their key
• has a O(logN) lookup and insert time
• Multi map can have multiple values to the one key

UNORDERED MAP
• Based on hash table
• Not sorted
• Fast for accessing individual elements by key

SET
• Elements themselves are the keys
• Elements in a set are always sorted from lower to higher
• Multi set can have multiple values to the one key

//////////////////////////////////////////////////////////////////////////////////////////////
//ITERATORS
//////////////////////////////////////////////////////////////////////////////////////////////

INPUT ITERATOR
• iterator that a program can use to read only
• single pass, one way iterator; can't back up once incremented
• each time one moves through container, different order of moving through elements

OUTPUT ITERATOR
• iterator that a program can use to write only
• single pass, one way iterator; can't back up once incremented
• each time one moves through container, different order of moving through elements

FORWARD ITERATOR
• Goes through sequence in same order each time
• Multi pass, can still access prior elements once incremented
• Read and write abilities

BIDIRECTIONAL ITERATOR
• Goes through sequence in same order each time
• Multi pass, Can increment and decrement
• Read and write abilities

RANDOM ACCESS ITERATOR
• Goes through sequence in same order each time
• Can jump to any element in container
• Multi pass, Can increment and decrement
• Read and write abilities

--------------------------------------------------------------------
Capability    Input   Output   Forward  Bidirectional Random Access
--------------------------------------------------------------------
Read          Yes     No       Yes      Yes           Yes
Write         No      Yes      Yes      Yes           Yes
Fixed order   No      No       Yes      Yes           Yes
++i/i++       Yes     Yes      Yes      Yes           Yes
--i/i--       No      No       No       Yes           Yes
i[n]          No      No       No       No            Yes
i+n, i-n      No      No       No       No            Yes
i+=n, i-=n    No      No       No       No            Yes

======================================================================================
ITERATOR TYPES
======================================================================================

CONTAINER ITERATORS
• Vector/Array/Deque: Random Access Iterator
• List: Bidirectional Iterator
• Forward List: Forward Iterator
• Map: Bidirectional Iterator
• Queue/Stack: No Iteration

BACK INSERT ITERATOR
• Output iterator
• inserts items at the end of the container. 
• calls .push_back(), only used with containers that have it (vector, deque, string, list)
• For set/maps, only affects insertion performance as values are sorted

FRONT INSERT ITERATOR
• Output iterator
• inserts items at the front of the container.
• calls .push_front(), only used with containers that have it (deque, list)
• For set/maps, only affects insertion performance as values are sorted

INSERT ITERATOR
• Output iterator
• inserts items in front of the location specified as an argument
• For set/maps, only affects insertion performance as values are sorted

OSTREAM ITERATOR
• Output iterator
• ineffecient due to lots of error checking/formatting

OSTREAMBUF ITERATOR
• Output iterator
• Faster than ostream_iterator

ISTREAM ITERATOR
• Input iterator
• ineffecient due to lots of error checking/formatting

ISTREAMBUF ITERATOR
• Input iterator
• Faster than istream_iterator, doesn't skip over any character
• directly grabs what's next in stream buffer, no extra checking/formatting

======================================================================================
ITERATOR INVALIDATION
======================================================================================

VECTOR/PRIORITY-QUEUE
• Insertion: Before point of insertion unaffected unless container size is 
  greather than previous capacity and vector needs to be recopied.
• Erasure: All after point of erase are invalidated.

DEQUE/QUEUE/STACK
• Insertion: All invalidated unless inserted member is at the front or back in
  which iterators are invalidated and references are not.
• Erasure: All invalidated unless erased member is at the front or back in
  which only the member erased is invalidated.

LIST/MAP/SET
• Inerstion: All unaffected.
• Erasure: Only the erased member is invalidated.

//////////////////////////////////////////////////////////////////////////////////////////////
//FILE MANAGEMENT
//////////////////////////////////////////////////////////////////////////////////////////////

BUFFER
• Bloack of memory for storage/transfer of information
• Flushed when endl, when full or when specified
• Controls rate of stream of bytes to/from buffer

BITMASK TYPES    
• OPENMODE: bitmask type for setting the file mode
• FMTFLAGS: Setting the formatting for the stream
• IOSTATE: A stream state contained in a cout/cin object
           eofbit  = Is set to 1 if end-of-file reached.
           badbit  = Is set to 1 if the stream has file read error
           failbit = Is set to 1 if an input operation failed to read/write expected characters

IOSTREAM
• Creates 8 stream objects (four narrow/four wide character streams)
  CIN/WCIN
  COUT/WCOUT
  CERR/WCERR (error stream unbuffered)
  CLOG/WCLOG (error stream)

FILESTREAM
• Redirects the input/output streams to either use a file instead of console
• This doesn't affect CERR or CLOG unless changed.

OSTREAM CLASS
• translates data as binary bit patterns to an output stream of char bytes
• ostream & operator<<(type); returns reference back to the ostream object
• all methods return ostream type allowing concatenation (cout.put(1).put(1))
• cout << "one" << endl; "one" sent to buffer, returns cout. 
• Endl reached, buffer flushes, inserts \n, no cout returned.

ISTREAM CLASS
• translates data as char from the input stream into binary bit patterns
• istream & operator>>(type &); returns reference back to the istream object
• all methods return istream type allowing concatenation

BINARY FILES
• Smaller, take up less room
• No hidden conversions; written in computer binary language
• More accurate as no conversion/round-off errors for numbers
• Risky as different computers have different internal representation