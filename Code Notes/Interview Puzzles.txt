/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//INTERVIEW PUZZLES
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Q: Write a function that computes the factorial of a number. Now write it again without using recursion.
A: Note that n cannot be negative and factorial of 0 is 1:

long FactorialRecursion(int n)
{
    return n == 0 ? 1 : n * FactorialRecursion(n-1);
}
   
long Factorial(int n)
{
    long result = 1;
    for (int c = 1; c <= n; ++c)
    {
        result *= c;
    }
    return result;    
}

==============================================================================================================

Q: Reverse a linked list
A: Called by ReverseList(root) or ReverseListRecursive(root, nullptr)

Node* ReverseList(Node* node)
{
    Node* temp = nullptr;
    Node* previous = nullptr;
    while(node != nullptr) 
    {
        temp = node->next;
        node->next = previous;
        previous = node;
        node = temp;
    }
    return previous;
}

Node* ReverseListRecursive(Node* node, Node* previous)
{
    if (node != nullptr)
    {
        Node* temp = node->next;
        node->next = previous;
        return ReverseListRecursive(temp, node);
    }
    return previous;
}

==============================================================================================================

Q: You have two identical eggs. Standing in front of a 100 floor building, you wonder what is the 
   maximum number of floors from which the egg can be dropped without breaking it. What is the 
   minimum number of tries needed to find out the solution?

A: By dropping one egg on each floor until it breaks you can easily find the maximum floors. The maximum
   floors is 100 if it doesn't break until the last floor. The minimum tries can be found by by going up 
   floors by intervals and if the first egg breaks, test the second egg in between the interval:

   Interval of 2:  100 / 2 = 50  with Maximum tries = 50 + 1 = 51
   Interval of 3:  100 / 3 = 33  with Maximum tries = 33 + 2 = 35
   Interval of 4:  100 / 4 = 25  with Maximum tries = 25 + 3 = 28
   Interval of 5:  100 / 5 = 20  with Maximum tries = 20 + 4 = 24
   Interval of 6:  100 / 6 = 16  with Maximum tries = 16 + 5 = 21
   Interval of 7:  100 / 7 = 14  with Maximum tries = 14 + 6 = 20
   Interval of 8:  100 / 8 = 12  with Maximum tries = 12 + 7 = 19
   Interval of 9:  100 / 9 = 11  with Maximum tries = 11 + 8 = 19
   Interval of 10: 100 / 10 = 10 with Maximum tries = 10 + 9 = 19
   Interval of 11: 100 / 11 = 9 with Maximum tries = 9 + 10 = 19
   Interval of 12: 100 / 12 = 8 with Maximum tries = 8 + 11 = 19
   Interval of 13: 100 / 13 = 7 with Maximum tries = 16 + 12 = 19
   Interval of 14: 100 / 14 = 7 with Maximum tries = 7 + 13 = 20

   Minimum Tries = (100 / n) + (n - 1)
   Minimum Tries is 19 by going up with an interval of 8-13

==============================================================================================================

Q: Write a method to generate a random number between 1 and 7, 
   given a method that generates a random number between 1 and 5
A: If a result of 0 is ignored, there is an equal amount of chance to get a value from 1-7 from the array:

int GetRand7()
{
    int values[5][5] = 
    {
        { 1, 2, 3, 4, 5 },
        { 6, 7, 1, 2, 3 },
        { 4, 5, 6, 7, 1 },
        { 2, 3, 4, 5, 6 },
        { 7, 0, 0, 0, 0 }
    };

    int result = 0;
    while (result == 0)
    {
        result = values[GetRand5()-1][GetRand5()-1];
    }
    return result;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//NP-COMPLETE/HARD PROBLEMS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

• Exercises in heuristics and approximation
• Time required to solve the problem using any currently known 
  algorithm increases very quickly as the size of the problem grows

============================================================================================================
TRAVELLING SALESMAN PROBLEM
============================================================================================================

Q: Given a number of cities and the costs of travelling from any city to any other city, what is the 
   least-cost round-trip route that visits each city exactly once and then returns to the starting city? 




============================================================================================================
KNAPSACK PROBLEM
============================================================================================================

Q: Given a set of items, each with a mass and a value, determine the number of each item to include in a 
   collection so that the total weight is less than or equal to a given limit and the total value is as 
   large as possible.



