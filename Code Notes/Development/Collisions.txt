///////////////////////////////////////////////////////////////////////////////////////////////////
//COLLISIONS
///////////////////////////////////////////////////////////////////////////////////////////////////

PERFECTLY ELASTIC COLLISION: collision with no loss of energy
COLLISION DETECTION: Detection/prediction of collision of objects
COLLISION RESOLUTION: Physics rules applied to the colliding objects as a result of the event
COLLISION EFFECTS: Events that arise as a result of the collision
CONSTRAINT BASED METHODS: Complex offline collision detection
IMPULSE BASED METHODS: Use impulse generated by collision to determine resulting velocities
OBJECT ALIGNED BOUNDING BOX: Box rotates with object and aligned to its axis
AXIS ALIGNED BOUNDING BOX: Box sides are aligned with the world axis

///////////////////////////////////////////////////////////////////////////////////////////////////
//PROXY COLLISIONS
///////////////////////////////////////////////////////////////////////////////////////////////////

==================================================================================================
LINE-LINE COLLISION
==================================================================================================
• Line equations: y₀ = m₀x₀ + c₀ and y₁ = m₁x₁ + c₁
• Find the common point where y₀ = y₁ and x₀ = x₁ through m₀x₀ + c = m₁x₁ + c₁ and solve for x
• Lines parallel if x cancels out and gives a false statement (eg. 0 = 1)
• Lines coincident (same) if x cancels out and gives a true statement (eg. 1 = 1)

==================================================================================================
LINE-PLANE COLLISION
==================================================================================================
                  • Plane equation: (P-P₀).n = 0
  ___\_______     • Line equation: L = L₀ + td
 /    \     /     • Intersection point when L = P
/__________/      • (L₀ + td - P₀).n = 0     expand out the dot:
        \         • td.n + (L₀ - P₀).n = 0   solve for t:
                  • t = (P₀ - L₀).n / d.n

==================================================================================================
POINT-LINE/PLANE COLLISIONS
==================================================================================================

DISTANCE TO LINE/PLANE
• n̂.(P-P₀) = distance where P is point and P₀ is a point on the line or plane
• Normal to line (x,y) is (-y,x) or (y,-x)
• Normal to plane is u X v or (a,b) for plane equation ax + by + c = 0
• Distance may be negative depending on side the point is on to the normal
• Point C is the closest point to P on the plane (will = P if distance is 0)
                                      
    Q = P-P₀                                       •P
    distance = dot(n, Q)                          ▲
    if distance == 0                             / 
        point on the plane                      / n
    else if distance > 0                     Q /  ▲
        point is on normal side          _____/___|_______
    else if distance < 0                /    /    |      /
        point is away from normal      /    •P₀---•C    / 
    C = (P-P₀) - (distance * n)       /________________/
                                       
BOUNDED LINES   
• P = P₀ + td line equation can be rearranged to Q = td as Q = P-P₀
• d is the vector of the ray to its full length
• Dot by d to get Q.d = td.d
• Rearrange to get t = Q.d / d.d
• t must be [0,1] to be on the line or > 0 to be on the ray

BOUNDED PLANES
• To check if inside bounds convert point world coordinates to barycentric coordinates
• u and v are the length of the bounding area
• P = P₀ + su + tv plane equation can be rearranged to Q = su + tv as Q = P-P₀
• Dot by u/v to get Q.v = (su + tv).v and Q.u = (su + tv).u
• Rearrange to get s = (Q.v - t(v.v)) / (u.v) and t = (Q.u - s(u.u)) / (u.v)
• Substitute each one into the other and find barycentric (s, t)

    uu = dot(u, u)
    vv = dot(v, v)
    uv = dot(u, v)
    Qv = dot(Q, v)
    Qu = dot(Q, u)
    t = ((uv * Qu) - (Qv * uu)) / ((uv * uv) - (vv * uu))
    s = ((Qv * uv) - (Qu * vv)) / ((uv * uv) - (uu * vv))
    if t >= 0 and s >= 0 and t+s <= 1
        point is inside triangle
    if t >= 0 and s >= 0 and t+s <= 2
        point is inside plane

==================================================================================================
SPHERE-POINT / CIRCLE-POINT COLLISION
==================================================================================================
• Point inside sphere if distance from sphere center to point is less than radius
    
   ₀ o ₀          distance = length(center - point)   
 o    ___o___•P   if distance < radius                
o     ----o           collision occured               
 o       o                                         
   ᴼ o ᴼ                                           

==================================================================================================
SPHERE-SPHERE / CIRCLE-CIRCLE COLLISION
==================================================================================================
• Two spheres colliding when distance between centers is less than combined radius
                        
    ₀ o ₀        ₀ o ₀      distance = length(centerA - centerB) 
  o    ___o____o___    o    radius = radiusA + radiusB           
 o     ----o  o----     o   if distance < radius                 
  o       o    o       o        collision occured                
    ᴼ o ᴼ        ᴼ o ᴼ                                            

==================================================================================================
SPHERE-RAY / CIRCLE-RAY COLLISION
==================================================================================================
• Sphere equation: (P-c).(P-c) = r²
• P.(P-c) - c.(P-c) = r²
• P.P - 2P.c + c.c = r²
• Substitute Line equation: P = P₀ + td
• (P₀ + td).(P₀ + td) - 2(P₀ + td).c + c.c = r²
• P₀.P₀ + 2tP₀.d + t²d.d - 2P₀.c - 2td.c + c.c = r²
• t²d.d + t(2P₀.d - 2d.c) + P₀.P₀ - 2P₀.c + c.c = r²
• (d.d)t² + 2(P₀ - c).dt + (P₀ - c).(P₀ - c) - r² = 0
• Using quadratic formula: at² + bt + c = 0 
• t = -b ± √(b² - 4ac) / 2a where t >= 0 to hit the sphere

==================================================================================================
CIRCLE-SQUARE COLLISION
==================================================================================================



==================================================================================================
SPHERE-CUBE COLLISION
==================================================================================================



==================================================================================================
CUBE-CUBE / SQUARE-SQUARE COLLISION
==================================================================================================
• Min is bottom left corner of box
• Max is top right corner of box
• AABB is aligned to the x,y,z axis with no rotation

CLOSEST POINT TO AABB
• Pushes P(x,y) into the box, if inside, returns original point
x = min(max(x, minX), maxX)
y = min(max(y, minY), maxY)
z = min(max(z, minZ), maxZ)

CUBE-CUBE COLLISION

   o-------o
  /|      /|      o-------o
 / |     / |     /|      /|
o--|----o  |    / |     / |
|  o----|--o   o--|----o  |
| /     | /    |  o----|--o
o-------o      | /     | /
               o-------o

SQUARE-SQUARE COLLISION        
                          if aMaxX < bMinX || aMinX > bMaxX              
   -----------aMax            no collision                      
   |          |           if aMaxY < bMinY || aMinY > bMaxY     
   |   -------|---bMax        no collision                      
   |   |      |   |       if aMaxz < bMinZ || aMinZ > bMaxZ     
aMin---|-------   |           no collision                      
       |          |       else                                  
    bMin-----------           collision    
                                                 
SQUARE-SQUARE INTERSECTION AREA                     
intMaxX = min(aMaxX, bMaxX)          
intMinX = max(aMinX, bMinX)
intMaxY = min(aMaxY, bMaxY)
intMinY = max(aMinY, bMinY)
intWidth =  max(0, intMaxX - intMinX)
intHeight = max(0, intMaxY - intMinY)

///////////////////////////////////////////////////////////////////////////////////////////////////
//COMPLEX COLLISIONS
///////////////////////////////////////////////////////////////////////////////////////////////////

==================================================================================================
LINE-INTERSECTION TECHNIQUE
==================================================================================================
• Supports concave/convex shapes but slow and ineffecient
• For each outside edge of the model, create a line
• Test this array of lines against other model's array of lines for each line

Line1: P₁(t) = P₁(0) + t₁d₁
Line2: P₂(t) = P₂(0) + t₂d₂
where d = vector between start/end point of line
where t = 0->1 when on the line

Collision occurs if both t₁ and t₂ are between 0 and 1

P₁(0) + t₁d₁ = P₂(0) + t₂d₂
► P₁(0)x + t₁d₁x = P₂(0)x + t₂d₂x
► P₁(0)y + t₁d₁y = P₂(0)y + t₂d₂y

and rearrange to solve for t₁ and t₂

==================================================================================================
GJK COLLISION ALGORITHM
==================================================================================================
• Collisions between convex hulls only

MINKOWSKI DIFFERENCE:
• Create from two convex hulls by subtracting all points of A from all points of B
• If contains the origin, both hulls are colliding
• As hulls get closer, Minkowski Difference hull gets closer to origin

GJK ALGORITHM:
• Doesn't require computing whole Minkowski Difference hull
• Builds a simplex inside the Minkowski Difference to see if it encloses the origin
• Uses a 'support' function to find the furthest point in the MD hull in a direction
  which helps create the simplex with the largest area enclosing the MD hull

CHOOSING THE INITIAL POINTS:
• Randomly choose a point in A and B and subract to get a direction between the two
• Find the point along that direction that is the furthest away (+ largest dot product)
• Generate the Minkowski Difference point of the chosen two points which is an edge point 
• Negate the direction

WHILE COLLISION IS NOT FOUND:
• Get a new edge point in the direction
• Check if this new point is past the origin (has a + dot product with it)
• If not past the origin, origin isn't inside the difference and collision cannot occur
• If line simplex: Cross the line and the last point to origin to get the next direction
• If a tri-plane simplex: Next direction is the normal that points towards the origin
• If a tetrahedron simplex: 
    - If origin is inside all three planes (the forth was checked as a tri plane) then collision
    - If origin is outside a plane, remove the furthest point
    - The next direction is the normal to the plane towards the origin

FINDING PENETRATION DEPTH
• Use Expanding Polytope Algorithm (EPA) with the terminating GJK simplex
• Find the triangle of simplex that is closest to the origin
• If the projected point of the origin does not lie within the triangle on the plane, find next closest
• Search along the triangle normal and find the Minkowski difference edge hull point
• If this point is close to the face, terminate as found
• If not close, extend the simplex to include this new point and continue loop
• Once closest face is found, penetration vector is face normal * distance to origin