///////////////////////////////////////////////////////////////////////////////////////////////////
//COLLISIONS
///////////////////////////////////////////////////////////////////////////////////////////////////

PERFECTLY ELASTIC COLLISION: collision with no loss of energy
COLLISION DETECTION: Detection/prediction of collision of objects
COLLISION RESOLUTION: Physics rules applied to the colliding objects as a result of the event
COLLISION EFFECTS: Events that arise as a result of the collision
CONSTRAINT BASED METHODS: Complex offline collision detection
IMPULSE BASED METHODS: Use impulse generated by collision to determine resulting velocities
OBJECT ALIGNED BOUNDING BOX: Box rotates with object and aligned to its axis
AXIS ALIGNED BOUNDING BOX: Box sides are aligned with the world axis

COLLISION DETECTION:
Once proxies are tested, to obtain greater accuracies, A/B are colliding if:
 ---------
| u.n < 0 | angle Ө > 90
 ---------
u = relative velocity of vertex Pᵃ of A colliding with B
n = normal to the plane of collsion

///////////////////////////////////////////////////////////////////////////////////////////////////
//PLANE-POINT COLLISION [SAME SIDE TECHNIQUE]
///////////////////////////////////////////////////////////////////////////////////////////////////

Test what side of each edge the origin is on

   c
   /\         u = b - a
  /  \        v = c - a
 /    \       n = u X v (pointing out screen)
/______\
a       b

Test AB Side:
n X (b-a) = ABN = vector pointing from b-a to center
(p-a) . ABN > 0 then true

Test AC Side:
n X (c-a) = ACN = vector pointing from c-a outwards
(p-a) . ACN < 0 then true

Test CB Side:
n X (c-b) = CBN = vector pointing from c-b to center
(p-b) . CBN > 0 then true

///////////////////////////////////////////////////////////////////////////////////////////////////
//PLANE-POINT COLLISION [BARYCENTRIC TECHNIQUE]
///////////////////////////////////////////////////////////////////////////////////////////////////

• Convert world coordinates of p into barycentric coordinates
• Plane equation: pp = su + tv where pp = p - p0 and is a point on the plane
• Dot by u/v to: pp.v = (su + tv).v and pp.u = (su + tv).u
• Rearrange to: s = (pp.v - t(v.v)) / (u.v) and t = (p.u - s(u.u)) / (u.v)
• For notes rearranging, see planes in maths section
• Substitute each one into the other and find s,t

D3DXVECTOR3 u = p1 - p0;
D3DXVECTOR3 v = p2 - p0;
D3DXVECTOR3 pp = pointOnPlane - p0; // to find pointOnPlane, use plane-ray collision

const float uu = D3DXVec3Dot(&u, &u);
const float vv = D3DXVec3Dot(&v, &v);
const float uv = D3DXVec3Dot(&u, &v);
const float pv = D3DXVec3Dot(&pp, &v);
const float pu = D3DXVec3Dot(&pp, &u);
const float t = ((uv * pu) - (pv * uu)) / ((uv * uv) - (vv * uu));
const float s = ((pv * uv) - (pu * vv)) / ((uv * uv) - (uu * vv));

const bool inside = t >= 0.0f && s >= 0.0f && t+s <= 1.0f; // determine if inside triangle
const bool inside = t >= 0.0f && s >= 0.0f && t+s <= 2.0f; // determine if inside plane

///////////////////////////////////////////////////////////////////////////////////////////////////
//PLANE-RAY COLLISION
///////////////////////////////////////////////////////////////////////////////////////////////////

• Plane equation: (P-P₀).n = 0
• Line equation: L = L₀ + td
• Intersection point when L = P
• (L₀ + td - P₀).n = 0     expand out the dot:
• td.n + (L₀ - P₀).n = 0   solve for t:
• t = (P₀ - L₀).n / d.n

// Determine if normal is facing the pick direction
const float faceDirection = D3DXVec3Dot(&face.normal, &direction);
if(faceDirection < 0.0f)
{
    const float epsilon = 0.001f;
    const float t = D3DXVec3Dot(&(face.origin - origin), &face.normal) / faceDirection;
    D3DXVECTOR3 intersection = origin + (t * direction);

    // Ensure point of intersection is on the plane
    assert(fabs(D3DXVec3Dot(&(intersection - face.origin), &face.normal)) <= epsilon);
            
    // Ensure ray is in front of the plane
    // To restrict the test to line-plane, check if t <= 1.0f
    bool success = t >= 0.0f;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//SPHERE-RAY COLLISION
///////////////////////////////////////////////////////////////////////////////////////////////////

• Sphere equation: (P-c).(P-c) = r²
• P.(P-c) - c.(P-c) = r²
• P.P - 2P.c + c.c = r²
• Substitute Line equation: P = P₀ + td
• (P₀ + td).(P₀ + td) - 2(P₀ + td).c + c.c = r²
• P₀.P₀ + 2tP₀.d + t²d.d - 2P₀.c - 2td.c + c.c = r²
• t²d.d + t(2P₀.d - 2d.c) + P₀.P₀ - 2P₀.c + c.c = r²
• (d.d)t² + 2(P₀ - c).dt + (P₀ - c).(P₀ - c) - r² = 0
• Using quadratic formula: at² + bt + c = 0 
• t = -b ± √(b² - 4ac) / 2a where t >= 0 to hit the sphere

const float radiusSqr = radius * radius;
const D3DXVECTOR3 CP0 = m_rayOrigin - center;
const double a = D3DXVec3Dot(&m_rayDirection, &m_rayDirection);
const double b = D3DXVec3Dot(&(2 * CP0), &m_rayDirection); 
const double c = D3DXVec3Dot(&CP0, &CP0) - radiusSqr; 

const double squaredComponent = (b * b) - (4 * a * c);
if(squaredComponent >= 0)
{
    const double squared = std::sqrt(squaredComponent);
    const double t1 = (-b + squared) / (2 * a);
    const double t2 = (-b - squared) / (2 * a);
    if(t1 >= 0 || t2 >= 0)
    {
        // Intersection occured
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//SPHERE-POINT / CIRCLE-POINT COLLISION
///////////////////////////////////////////////////////////////////////////////////////////////////

• Point inside sphere if distance from sphere center to point is less than radius

const float distance = (center - point).Length();
if (distance < radius)
{
    // Collision occured
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//SPHERE-SPHERE / CIRCLE-CIRCLE COLLISION
///////////////////////////////////////////////////////////////////////////////////////////////////

• Two spheres colliding when distance between centers is less than combined radius

const float distance = (centerA - centerB).Length();
const float combinedRadius = radiusA + radiusB;
if (distance < combinedRadius)
{
    // Collision occured
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//SQUARE-SQUARE COLLISION
///////////////////////////////////////////////////////////////////////////////////////////////////

• Min is bottom left corner of box
• Max is top right corner of box

if(BoxA->max.x < BoxB->min.x || BoxA->min.x > BoxB->max.x)
    return false;
if(BoxA->max.y < BoxB->min.y || BoxA->min.y > BoxB->max.y)
    return false;
if(BoxA->max.z < BoxB->min.z || BoxA->min.z > BoxB->max.z)
    return false;
else
    return true;

IntersectionMaxX = std::min(BoxA->max.x, BoxB->max.x);
IntersectionMinX = std::max(BoxA->min.x, BoxB->min.x);
IntersectionMaxY = std::min(BoxA->max.y, BoxB->max.y);
IntersectionMinY = std::max(BoxA->min.y, BoxB->min.y);

IntersectionWidth = std::max(0, IntersectionMaxX - IntersectionMinX);
IntersectionHeight = std::max(0, IntersectionMaxY - IntersectionMinY);

///////////////////////////////////////////////////////////////////////////////////////////////////
//CONVEX/CONCAVE COLLISIONS [LINE-INTERSECTION TECHNIQUE]
///////////////////////////////////////////////////////////////////////////////////////////////////

• supports concave/convex shapes but slow and ineffecient
• For each outside edge of the model, create a line
• Test this array of lines against other model's array of lines for each line

Line1: P₁(t) = P₁(0) + t₁d₁
Line2: P₂(t) = P₂(0) + t₂d₂
where d = vector between start/end point of line
where t = 0->1 when on the line

Collision occurs if both t₁ and t₂ are between 0 and 1

P₁(0) + t₁d₁ = P₂(0) + t₂d₂

► P₁(0)x + t₁d₁x = P₂(0)x + t₂d₂x
► P₁(0)y + t₁d₁y = P₂(0)y + t₂d₂y

and rearrange to solve for t₁ and t₂

///////////////////////////////////////////////////////////////////////////////////////////////////
//CONVEX COLLISIONS [GJK COLLISION ALGORITHM]
///////////////////////////////////////////////////////////////////////////////////////////////////

MINKOWSKI DIFFERENCE:
• Create from two convex hulls by subtracting all points of A from all points of B
• If contains the origin, both hulls are colliding
• As hulls get closer, Minkowski Difference hull gets closer to origin

GJK ALGORITHM:
• Doesn't require computing whole Minkowski Difference hull
• Builds a simplex inside the Minkowski Difference to see if it encloses the origin
• Uses a 'support' function to find the furthest point in the MD hull in a direction
  which helps create the simplex with the largest area enclosing the MD hull

CHOOSING THE INITIAL POINTS:
• Randomly choose a point in A and B and subract to get a direction between the two
• Find the point along that direction that is the furthest away (+ largest dot product)
• Generate the Minkowski Difference point of the chosen two points which is an edge point 
• Negate the direction

WHILE COLLISION IS NOT FOUND:
• Get a new edge point in the direction
• Check if this new point is past the origin (has a + dot product with it)
• If not past the origin, origin isn't inside the difference and collision cannot occur
• If line simplex: Cross the line and the last point to origin to get the next direction
• If a tri-plane simplex: Next direction is the normal that points towards the origin
• If a tetrahedron simplex: 
    - If origin is inside all three planes (the forth was checked as a tri plane) then collision
    - If origin is outside a plane, remove the furthest point
    - The next direction is the normal to the plane towards the origin

FINDING PENETRATION DEPTH
• Use Expanding Polytope Algorithm (EPA) with the terminating GJK simplex
• Find the triangle of simplex that is closest to the origin
• If the projected point of the origin does not lie within the triangle on the plane, find next closest
• Search along the triangle normal and find the Minkowski difference edge hull point
• If this point is close to the face, terminate as found
• If not close, extend the simplex to include this new point and continue loop
• Once closest face is found, penetration vector is face normal * distance to origin

///////////////////////////////////////////////////////////////////////////////////////////////////
//COLLISION RESOLUTION
///////////////////////////////////////////////////////////////////////////////////////////////////

 ---------------
| uᶠ.n = -euⁱ.n |
 ---------------
 uⁱ/uᶠ = relative velocity before/after collision
 n = plane of collision
 e = amount of energy lost during collision where 0 ≤ e ≤ 1
     e = 1; pefectly elastic collision
     e = 0; all energy lost and objects stop

 When storing object's mass, only store ¹/m
 For collisions involving large static objects, set objects mass to ¹/∞

==============================================================================
NON-ROTATING OBJECTS
==============================================================================
 -----------
| u = vᵃ-vᵇ | 
 -----------
 u = Relative velocity of vertex Pᵃ on A which collides with object B
 vᵃ,vᵇ = Linear velocity = Translational velocity

RESULT IN COLLISION: 

change in velocity for A and B
 --------------------------
| vᵃ(f) = vᵃ(i) + (¹/mᵃ)Jn |
| vᵇ(f) = vᵇ(i) - (¹/mᵇ)Jn |
 --------------------------
Use these values and uᶠ.n = -euⁱ.n to find equation for impulse(J) 

==============================================================================
ROTATING OBJECTS
==============================================================================
 -----------
| u = vᵃ-vᵇ | 
 -----------
 u = Relative velocity of vertex Pᵃ on A which collides with object B
 vᵃ/vᵇ = Linear velocity 
       = Translational(translation) + Tangential velocity(rotation)
         v = vᵗ + vᵀ = vᵗ + w X r

RESULT IN COLLISION: 

change in translational velocity for A and B
 --------------------------
| vᵗᵃ(f) = vᵃ(i) + (¹/mᵃ)Jn |
| vᵗᵇ(f) = vᵇ(i) - (¹/mᵇ)Jn |
 --------------------------
change in angular velocity for A and B
 --------------------------------
| wᵃ(f) = wᵃ(i) + (¹/iᵃ)(r X Jn) |
| wᵇ(f) = wᵇ(i) - (¹/iᵇ)(r X Jn) |
 --------------------------------
 Use these values to find equation for impulse(J)

///////////////////////////////////////////////////////////////////////////////////////////////////
//MOUSE MOVEMENT ALONG AXIS
///////////////////////////////////////////////////////////////////////////////////////////////////

• axis is any vector in 3D space that the mouse has to move along/away from
• invViewMatrix is camera world matrix
• Mouse direction aligned with axis if dot > 0.0f

D3DXVECTOR3 mouseDirection(-(position.x-previous.x), position.y-previous.y, 0.0f);
D3DXVec3Normalize(&mouseDirection, &mouseDirection);
mouseDirection.z = CAMERA_NEAR;
D3DXVec3TransformNormal(&mouseDirection, &mouseDirection, &invProjectionMatrix);
D3DXVec3TransformNormal(&mouseDirection, &mouseDirection, &invViewMatrix);
D3DXVec3Normalize(&mouseDirection, &mouseDirection);
D3DXVec3Normalize(&axis, &axis);
const float dot = D3DXVec3Dot(&axis, &mouseDirection);

///////////////////////////////////////////////////////////////////////////////////////////////////
//MOUSE RAY-CASTING
///////////////////////////////////////////////////////////////////////////////////////////////////

• Generate a mouse origin and direction in view space coordinates
• Convert the origin/direction to mesh local coordinates
• For every face in the local mesh:
    - Determine if normal is facing the ray direction
    - Find the ray-plane intersection point
    - Find if this intersection point is within the triangle
    - Determine if intersection distance is smaller than before

m_distanceToMesh = FLT_MAX;
rayOrigin = world.Position();

// Create screen space mouse ray
D3DXVECTOR3 mouseRay;
mouseRay.x =  (((2.0f*x)/WINDOW_WIDTH )-1) / projection.GetMatrix()._11;
mouseRay.y = -(((2.0f*y)/WINDOW_HEIGHT)-1) / projection.GetMatrix()._22;
mouseRay.z =  CAMERA_NEAR;

// Convert to view space mouse ray (camera world is inverse view matrix)
D3DXVec3TransformNormal(&rayDirection, &mouseRay, &world.GetMatrix());

// Convert origin/direction into local mesh coordinates
D3DXMATRIX worldInverse;
D3DXVECTOR3 origin, direction;
D3DXMatrixInverse(&worldInverse, 0, &world);
D3DXVec3TransformCoord(&origin, &rayOrigin, &worldInverse);
D3DXVec3TransformNormal(&direction, &rayDirection, &worldInverse);
D3DXVec3Normalize(&direction, &direction);

// For each face in local coordinates
for(const Face& face : m_faces)
{
    D3DXVECTOR3 u = face.p1 - face.p0;
    D3DXVECTOR3 v = face.p2 - face.p0;

    D3DXVECTOR3 normal;
    D3DXVec3Cross(&normal, &u, &v);
    D3DXVec3Normalize(&normal, &normal);

    // Determine if normal is facing the pick direction
    const float faceDirection = D3DXVec3Dot(&face.normal, &direction);
    if(faceDirection < 0.0f)
    {
        // Find the line-plane intersection point
        // Plane: (P-P₀).n = 0, Line: L = L₀ + td
        // Intersection point when L = P
        // Expand and Substitute for t = (P₀ - L₀).n / d.n
        const float epsilon = 0.001f;
        const float t = D3DXVec3Dot(&(face.origin - origin), &face.normal) / faceDirection;
        D3DXVECTOR3 intersection = origin + (t * direction);

        // Ensure point of intersection is on the plane
        assert(fabs(D3DXVec3Dot(&(intersection - face.origin), &face.normal)) <= epsilon);
            
        // Ensure ray is in front of the plane
        if(t >= 0.0f)
        {
            // Convert world coordinates of p into barycentric coordinates 
            // p is a point on the plane found through plane-ray intersection
            // Plane equation: planeToPoint = su + tv where planeToPoint = p - p0
            // Dot by u/v to: pp.v = (su + tv).v and pp.u = (su + tv).u
            // Rearrange to: s = (pp.v - t(v.v)) / (u.v) and t = (p.u - s(u.u)) / (u.v)
            // Substitute each one into the other and find s,t
            D3DXVECTOR3 planeToPoint = intersection - face.origin;
            const float uu = D3DXVec3Dot(&u, &u); 
            const float vv = D3DXVec3Dot(&v, &v);
            const float uv = D3DXVec3Dot(&u, &v);
            const float pv = D3DXVec3Dot(&planeToPoint, &face.v); 
            const float pu = D3DXVec3Dot(&planeToPoint, &face.u);
            float denominator = (uv * uv) - (vv * uu);
            denominator = denominator == 0.0f ? epsilon : denominator;
            const float bt = ((uv * pu) - (pv * uu)) / denominator;
            const float bs = ((pv * uv) - (pu * vv)) / denominator;

            // Determine if inside half of the plane (triangle)
            if(bt >= 0.0f && bs >= 0.0f && bs + bt <= 1.0f)
            {
                // Convert back to world coordinates to find the distance
                D3DXVec3TransformCoord(&intersection, &intersection, &world);
                const float distanceToMesh = D3DXVec3Length(&(intersection - rayOrigin));
                if(distanceToMesh < m_distanceToMesh)
                {
                    // Set the new mesh as selected
                    m_distanceToMesh = distanceToMesh;
                    return true;
                }
            }
        }
    }
}